# 第一周_付清晨

本周主要是 `array` 的简单题。

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   4    |   4    |   1    |

## II 本周刷题总结

### 第1题：[两数相加](https://leetcode-cn.com/problems/add-two-numbers/description/)

|  Category  |   Difficulty    | Runtime | Memory usage |
| :--------: | :-------------: | :-----: | :----------: |
| algorithms | Medium (38.77%) |  36 ms  |   69.5 MB    |

#### a. 原题陈述

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

#### b. 解题思路

这个题目刚好和传统意义的加法是一样的。

`l1` 和 `l2` 的第一个元素是个位，把个位数字相加就得到了和，这个和也就是答案的第一个元素（`result->val`），然后可能还有一个进位（`carry`）。运算完第一个之后就开始看第二个元素，把进位和这两个数字相加就是答案的第二个元素，当然也有可能有一个进位。以此类推就得到了答案。

如果其中一个列表访问完了（`l* == nullptr`），则这个数字的其他位补0。整个循环的结束条件就是两个元素都访问完了就结束了。

#### c. 解题代码：[两数相加.cpp](Source/2.两数相加.cpp) 

```cpp
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int carry = 0;	// 进位
        ListNode *result, *temp = new ListNode(), *flag;
        result = temp;	// head
        while (l1 || l2){
            // 前处理
            int val1 = 0, val2 = 0;
            if (l1){ val1 = l1->val; l1 = l1->next; }	// 补0
            if (l2){ val2 = l2->val; l2 = l2->next; }	// 补0
            // 计算
            int sum = val1 + val2 + carry; 
            carry = sum / 10;
            temp->val = sum % 10;
            // 后处理
            temp->next = new ListNode();
            flag = temp; temp = temp->next;
        }
        if (carry){ temp->val = 1; }
        else{ flag->next = nullptr; delete temp; }
        return result;
    }
```

#### d. 其他解法摘录

好像主要的就这一种了

### 第2题：[最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/description/)

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Easy (56.80%) |  166  |    -     |


#### a. 原题陈述


给定一个二进制数组， 计算其中最大连续1的个数。

**示例 1:**

```
输入: [1,1,0,1,1,1]
输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
```

**注意：**

- 输入的数组只包含 `0` 和`1`。
- 输入数组的长度是正整数，且不超过 10,000。

#### b. 解题思路

遍历数组，然后分情况处理

#### c. 解题代码： [485.最大连续-1-的个数.cpp](Source/485.最大连续-1-的个数.cpp) 

```cpp
int findMaxConsecutiveOnes(vector<int>& nums) {
    int sum = 0, max = 0;
    for (auto iter = nums.begin(); iter != nums.end(); iter++){
        if (*iter){ ++sum; if (max < sum){ max = sum; } }
        else{ sum = 0; }
    }
    return max;
}
```

#### d. 其他解法摘录

这个蛮简单，都一样的思路。

### 第3题：[移动零](https://leetcode-cn.com/problems/move-zeroes/description/)

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Easy (62.60%) |  951  |    -     |

#### a. 原题陈述


给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

#### b. 解题思路

设置两个哨兵，一个指示要更改数值的位置，一个指示当前查看的位置

#### c. 解题代码： [283.移动零.cpp](Source/283.移动零.cpp) 

```cpp
void moveZeroes(vector<int>& nums) {
    int curLocal = 0, size = nums.size(), numOfZero = 0;
    for(auto iter = nums.begin(); iter != nums.end(); ++iter){
        if(*iter == 0){ ++numOfZero; continue; }
        nums.at(curLocal++) = *iter;
    }
    while (curLocal < size){ nums.at(curLocal++) = 0; }
}
```

#### d. 其他解法摘录

简单题，略

### 第4题： [移除元素](https://leetcode-cn.com/problems/remove-element/description/)

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Easy (58.90%) |  765  |    -     |

#### a. 原题陈述


给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。


**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`


#### b. 解题思路

和上一题一样，设置两个哨兵，一个指示要更改数值的位置，一个指示当前查看的位置

#### c. 解题代码： [27.移除元素.cpp](Source/27.移除元素.cpp) 

```cpp
int removeElement(vector<int>& nums, int val) {
    int curLocal = 0;
    bool changed = false;
    for (auto iter = nums.begin(); iter != nums.end(); ++iter){
        if (*iter == val){ changed = true; continue; }
        if (changed){ nums.at(curLocal) = *iter; }
        ++curLocal;
    }
    return curLocal;
}
```

#### d. 其他解法摘录

简单题，略