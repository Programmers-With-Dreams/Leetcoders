# 第一周_付清晨

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   1    |   3    |  0.33  |

## II 本周刷题总结

### 第1题：[两数相加](https://leetcode-cn.com/problems/add-two-numbers/description/)

|  Category  |   Difficulty    | Runtime | Memory usage |
| :--------: | :-------------: | :-----: | :----------: |
| algorithms | Medium (38.77%) |  36 ms  |   69.5 MB    |

#### a. 原题陈述

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。



**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```

**示例 2：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

**示例 3：**

```
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

 

**提示：**

- 每个链表中的节点数在范围 `[1, 100]` 内
- `0 <= Node.val <= 9`
- 题目数据保证列表表示的数字不含前导零

#### b. 解题思路

这个题目刚好和传统意义的加法是一样的。

`l1` 和 `l2` 的第一个元素是个位，把个位数字相加就得到了和，这个和也就是答案的第一个元素（`result->val`），然后可能还有一个进位（`carry`）。运算完第一个之后就开始看第二个元素，把进位和这两个数字相加就是答案的第二个元素，当然也有可能有一个进位。以此类推就得到了答案。

如果其中一个列表访问完了（`l* == nullptr`），则这个数字的其他位补0。整个循环的结束条件就是两个元素都访问完了就结束了。

#### c. 解题代码：[两数相加.cpp](Source\2.两数相加.cpp) 

```cpp
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int carry = 0;	// 进位
        ListNode *result, *temp = new ListNode(), *flag;
        result = temp;	// head
        while (l1 || l2){
            // 前处理
            int val1 = 0, val2 = 0;
            if (l1){ val1 = l1->val; l1 = l1->next; }	// 补0
            if (l2){ val2 = l2->val; l2 = l2->next; }	// 补0
            // 计算
            int sum = val1 + val2 + carry; 
            carry = sum / 10;
            temp->val = sum % 10;
            // 后处理
            temp->next = new ListNode();
            flag = temp; temp = temp->next;
        }
        if (carry){ temp->val = 1; }
        else{ flag->next = nullptr; delete temp; }
        return result;
    }
```

#### d. 其他解法摘录

好像主要的就这一种了

### 第2题：[无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/description/)

|  Category  |   Difficulty    | Likes | Dislikes |
| :--------: | :-------------: | :---: | :------: |
| algorithms | Medium (35.79%) | 4931  |    -     |

#### a. 原题陈述

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。


**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**示例 4:**

```
输入: s = ""
输出: 0
```

 

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

#### b. 解题思路



#### c. 解题代码



#### d. 其他解法摘录



### 第3题：[寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/)

|  Category  |  Difficulty   | Likes | Dislikes |
| :--------: | :-----------: | :---: | :------: |
| algorithms | Hard (38.93%) | 3677  |    -     |

#### a. 原题陈述

给定两个大小为 m 和 n 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数。

**进阶：**你能设计一个时间复杂度为 `O(log (m+n))` 的算法解决此问题吗？

 

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**示例 3：**

```
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```

**示例 4：**

```
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

**示例 5：**

```
输入：nums1 = [2], nums2 = []
输出：2.00000
```

 

**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`

#### b. 解题思路



#### c. 解题代码



#### d. 其他解法摘录

