# 第五周_付清晨

本周主要是 `回溯算法` 、`DFS` 的中等题。

## I 本周目标


|   分类   |    计划完成题目    | 已完成数量 |
| :------: | :----------------: | :--------: |
| 回溯算法 | **22**，**78**，77，46 |     4     |
| DFS |   938，78，**200**   |     3     |
|   汇总   |       共6个       |     6      |


## II 本周刷题总结

### 回溯算法

回溯就是递归。。。然后回溯好像是DFS的一类，只不过涉及到恢复之前的状态

如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法，可以使用回溯算法

|   题目   |    难度    | 描述 | 解题方法 |
| :------: | :----------------: | :--------: | :------: |
| **22：括号生成** | 中等 | 设计函数：生成所有可能且有效的 n 对括号组合 | **回溯**、**动态规划** |
| **78：子集** | 中等 | 返回所给数组所有可能的子集 | **回溯、递归** |
|   77：组合   | 中等 | 给两整数 n, k，返回 1 ... n 中所有可能的 k 个数的组合 | **回溯** |
| 46：全排列 | 中等 | 给定没有重复数字的序列，返回所有可能的全排列 | **回溯** |

#### 22：括号生成

  - **回溯法**：有效的括号组合就是在写括号的过程中，`(`始终比`)`要多。再加上括号的数量是确定的，因此可以设置两个变量分别记录两种括号的数量。遍历决策树，发现无效（`(`比`)`少）的剪枝。当两种括号的数量都达到上限了，这时一个符合条件的组合就生成了。遍历完成后所有的组合情况就都实现了

    ```cpp
    vector<string> results;			// ⬇剩余的左括号数和右括号数
    void generateRec(string &result, int numLOP, int numROP, int size){
      if(!size){ results.push_back(result); return; }	// 生成了符合条件的组合
        if(numROP < numLOP) { return; }					// 无效，剪枝
      result.push_back(')'); generateRec(result, numLOP, --numROP, --size);
        ++numROP; ++size; result.pop_back();			// 回溯还原
      if(!numLOP){ return; }							// 左括号用完了
        result.push_back('('); generateRec(result, --numLOP, numROP, --size);
        ++numLOP; ++size; result.pop_back();			// 回溯还原
    }
    vector<string> generateParenthesis(int n) {
        string init;
        generateRec(init, n, n, 2 * n);
        return results;
    }
    ```
  
  - **动态规划**：有$n$ 对括号的组合都可以写成 $f_n=(+f_i+)+f_{n-i},f_0=\text{null},f_1=()$ 
  
    > 动态规划真是巧妙，可惜这种式子不好遇到
    
    ```cpp
    	vector<string> generateParenthesis(int n) {
    		if (n == 0) return {};
    		if (n == 1) return { "()" };
    		vector<vector<string>> dp(n+1);		// 空间换时间
    		dp[0] = { "" }; dp[1] = { "()" };
    		for (int i = 2; i <= n; i++)
    			for (int j = 0; j < i; j++)
    				for (string p : dp[j])
    					for (string q : dp[i - j - 1]) {
    						string str = "(" + p + ")" + q;
    						dp[i].push_back(str);
                        }
            return dp[n];
    	}
    ```

#### 78：子集

  - **回溯法**：和上题差不多，不用考虑无效的情况，但是要考虑组合的长度

    ```cpp
    vector<vector<int>> results;
    void subsetRec(vector<int> &nums,vector<int> &result, int begin, int subSize) {
        if(!subSize) { results.push_back(result); return; }
        int size = nums.size();
        for (int i = begin; i < size; ++i) {
            result.push_back(nums.at(i));
            subsetRec(nums, result, i + 1, subSize - 1);
            result.pop_back();
        }
    }    
    vector<vector<int>> subsets(vector<int>& nums) {
        int size = nums.size();
        for (int i = 0; i <= size; i++) { 
            vector<int> temp; 
            subsetRec(nums, temp, 0, i);
        }
        return results;
    }
    ```

  - **递归法**：这个题目有一个特点，数组子集的所有情况可以通过一个二进制数表示，这个二进制数的位数刚好对应数组元素的数量，例如`[1,2]`的4种情况：`00->[],01->[2],10->[1],11->[1,2]` （`0`表示没`1`表示有）

    > 这种方法妙在结合了离散数学，然后这里要小心数组元素的个数，超过32就要换数据类型了
    
    ```cpp
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> results;
        int size = nums.size();
        for (int mask = 0; mask < (1 << size); ++mask) {	//mask就是对应的二进制数
            vector<int> temp;
            for (int i = 0; i < size; ++i) { 	// i表示数组的第i个元素
                if (mask & (1 << i)) { temp.push_back(nums.at(i)); } }
                results.push_back(temp);
            }
            return results;
    }
    ```
    

#### 77：[组合](https://leetcode-cn.com/problems/combinations/description/)

写了前两题，这个就很简单了

```cpp
vector<vector<int>> result;
void combineRec(vector<int> &nums, int begin, int k, int n) {
    if (!k) { result.push_back(nums); return; }
    for (int i = begin; i <= n; i++) {
        nums.push_back(i);
        combineRec(nums, i + 1, k - 1, n);
        nums.pop_back();
    }
}	// 这里还可以优化，就是 n - begin < k 时，就可以直接返回，因为选不出来了
vector<vector<int>> combine(int n, int k) {
    vector<int> temp; combineRec(temp, 1, k, n); return result;
}
```

#### 46：[全排列](https://leetcode-cn.com/problems/permutations/description/)

经典回溯法例题

```cpp
vector<vector<int>> result;
void permuteRec(vector<int> &nums, int begin, int end){
    if (begin == end){ result.push_back(nums); return; }
    for (int i = begin; i < end; ++i){
        int temp = nums.at(begin); nums.at(begin) = nums.at(i); nums.at(i) = temp;
        permuteRec(nums, begin + 1, end);
        temp = nums.at(begin); nums.at(begin) = nums.at(i); nums.at(i) = temp;
    }
}	// 套路都是一样的
vector<vector<int>> permute(vector<int>& nums) {
    permuteRec(nums, 0, nums.size());
    return result;
}
```

### DFS

|   题目   |    难度    | 描述 | 解题方法 |
| :------: | :----------------: | :--------: | :------: |
| 938：[BST范围和](https://leetcode-cn.com/problems/range-sum-of-bst/description/) | 简单 | 给BST的根结点，求树中位于 `[low,high]` 间所有结点值的和 | **DFS**(迭代)  |
| **200：[岛屿数量](https://leetcode-cn.com/problems/number-of-islands/description/)** | 中等 | 给定由 `'1'陆`和 `'0'水`组成的网格，计算网格中岛屿的数量 | **回溯、递归** |

#### 938：[二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/description/)

DFS经典解法

- DFS(迭法)

  ```cpp
  int rangeSumBST(TreeNode* root, int low, int high) {
      stack<TreeNode *> treeNodeStack; treeNodeStack.push(root); int sum = 0;
      while (!treeNodeStack.empty()){
          TreeNode *currNode = treeNodeStack.top(); treeNodeStack.pop();
          if (low <= currNode->val && currNode->val <= high) { sum += currNode->val; }
          if (currNode->left  && low < currNode->val ) { treeNodeStack.push(currNode->left ); }
          if (currNode->right && currNode->val < high) { treeNodeStack.push(currNode->right); }
      }
      return sum;
  }
  ```

- DFS(递归)

  ```cpp
  int rangeSumBST(TreeNode* root, int low, int high) {
      if (!root) { return sum; }
      int sum = 0;
      if (low <= root->val && root->val <= high) { sum += root->val; }
      if (low < root->val) { rangeSumBST(root->left, low, high); }
      if (root->val < high) { rangeSumBST(root->right, low, high); }
      return sum;
  }
  ```

#### 200：[岛屿数量](https://leetcode-cn.com/problems/number-of-islands/description/)

这个题目还挺有意思

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

**示例 **

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

解题思路就是对每个没访问过的陆地进行一遍DFS，进行DFS的数量就是岛屿的数量

```cpp
int numIslands(vector<vector<char>>& grid) {
    int sizeR = grid.size(), sizeC = grid.at(0).size(), number = 0;
    for (int i = 0; i < sizeR; ++i) {
        for (int j = 0; j < sizeC; ++j) {
            if (grid.at(i).at(j) != '1') { continue; }    // 被访问了/水:跳过
            stack<pair<int, int>> islandStack;
            islandStack.push({i, j}); 
            grid[i][j] = '2';
            while (!islandStack.empty()) {
                int tempR = islandStack.top().first;
                int tempC = islandStack.top().second;
                grid.at(tempR).at(tempC) = '2';
                islandStack.pop();
                if (tempR + 1 < sizeR && grid.at(tempR + 1).at(tempC) == '1') 
                { islandStack.push({tempR + 1, tempC}); }	// 右
                if (tempC + 1 < sizeC && grid.at(tempR).at(tempC + 1) == '1') 
                { islandStack.push({tempR, tempC + 1}); }	// 下
                if (0 <= tempR - 1 && grid.at(tempR - 1).at(tempC) == '1') 
                { islandStack.push({tempR - 1, tempC}); }	// 左
                if (0 <= tempC - 1 && grid.at(tempR).at(tempC - 1) == '1') 
                { islandStack.push({tempR, tempC - 1}); }	// 上
            }
            ++number;
        }
    }
    return number;
}
```

### BFS

BFS就是把DFS的 `stack` 换成了 `queue`

#### 102：[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/description/)

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

标标准准的BFS问题

```cpp
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> results;
        if (root == nullptr) { return results; }
        queue<TreeNode *> treeQueue;
        treeQueue.push(root);
        while (!treeQueue.empty()) {
            int size = treeQueue.size();
            results.push_back(vector<int> ());
            for (int i = 0; i < size; ++i) {
                TreeNode *temp = treeQueue.front(); treeQueue.pop();
                if (temp->left ) { treeQueue.push(temp->left ); }
                if (temp->right) { treeQueue.push(temp->right); }
                results.back().push_back(temp->val);
            }
        }
        return results;
    }
```

#### 107：[二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/description/)

给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

102 + `reverse`

