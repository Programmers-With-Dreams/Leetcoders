# 第二周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   3    |   5    |  60%   |

## II 本周刷题总结

### 第1题 [从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

难度：中等

类型：树

方法：层次遍历

#### a. 原题陈述

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

#### b. 解题思路

构造队列数据结构，实现层次遍历

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root == null) return new int[0];
        // 层次遍历
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.add(root);
        List<Integer> result = new ArrayList<Integer>();
        // 循环层次添加节点值入返回数组
        while(!queue.isEmpty()){
            TreeNode tem = queue.poll();
            // 存入result数组
            result.add(tem.val);
            // 左右子树根节点入队列
            if(tem.left!=null) queue.add(tem.left);
            if(tem.right!=null) queue.add(tem.right);
        }
        return result.stream().mapToInt(Integer::intValue).toArray();
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int[] levelOrder(TreeNode root) {
        if(root == null) return new int[0];
        Queue<TreeNode> queue = new LinkedList<>(){{ add(root); }};
        ArrayList<Integer> ans = new ArrayList<>();
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            ans.add(node.val);
            if(node.left != null) queue.add(node.left);
            if(node.right != null) queue.add(node.right);
        }
        int[] res = new int[ans.size()];
        for(int i = 0; i < ans.size(); i++)
            res[i] = ans.get(i);
        return res;
    }
}

```

此处，ArrayList转换为int[]的方法与上面采用的有所不同，更容易理解。

------



### 第2题 [从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

难度：简单

类型：树

方法：层次遍历

#### a. 原题陈述

从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。

#### b. 解题思路

层次遍历，根据当前队列的size进行循环输出

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        
        // 初始化数据结构
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        if(root!=null) queue.add(root);
        
        // 循环处理
        while(!queue.isEmpty()){
            List<Integer> _res = new ArrayList<Integer>();
            for(int i = queue.size();i>0;i--){
                TreeNode tem = queue.poll();
                 _res.add(tem.val);
                // 左右子树根节点入队列
                if(tem.left!=null) queue.add(tem.left);
                if(tem.right!= null) queue.add(tem.right);
            }
            res.add(_res);
        }
        return res;
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        // 构造数据结构
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) {
            List<Integer> tmp = new ArrayList<>();
            // 根据queue的size来决定循环次数
            for(int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                tmp.add(node.val);
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}

```



------



### 第3题 [从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

难度：中等

类型：树

方法：层次遍历

#### a. 原题陈述

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

#### b. 解题思路

使用一个boolean值判断方向，逆向用反转数组处理

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        
        // 初始化数据结构
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        if(root!=null) queue.add(root);
        boolean flag = true;//true代表从左到右，false代表从右到左
        
        // 循环处理
        while(!queue.isEmpty()){
            List<Integer> _res = new ArrayList<Integer>();
            if(flag == true){
                for(int i = queue.size();i>0;i--){
                    TreeNode tem = queue.poll();
                    _res.add(tem.val);
                    // 左右子树根节点入队列
                    if(tem.left!=null) queue.add(tem.left);
                    if(tem.right!= null) queue.add(tem.right);
                }
                flag = false;
            }else{
                ArrayList<Integer> _tem = new ArrayList<>();
                for(int i = queue.size();i>0;i--){
                    TreeNode tem = queue.poll();
                    // _res.add(tem.val);
                    _tem.add(tem.val);
                    // 左右子树根节点入队列
                    if(tem.left!=null) queue.add(tem.left);
                    if(tem.right!= null) queue.add(tem.right);
                }
                int _size = _tem.size();
                for(int i = 0; i < _size; i++){
                    _res.add(_tem.get(_size-i-1));
                }     
                flag = true;           
            }
            
            res.add(_res);
        }
        return res;
    }    
}
```

#### d. 其他解法摘录

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        if(root != null) queue.add(root);
        while(!queue.isEmpty()) {
            // 用链表数据结构，前插后插更方便
            LinkedList<Integer> tmp = new LinkedList<>();
            for(int i = queue.size(); i > 0; i--) {
                TreeNode node = queue.poll();
                // 巧用res.size()来判断当前层是奇数层还是偶数层
                if(res.size() % 2 == 0) tmp.addLast(node.val); // 偶数层 -> 队列头部
                else tmp.addFirst(node.val); // 奇数层 -> 队列尾部
                if(node.left != null) queue.add(node.left);
                if(node.right != null) queue.add(node.right);
            }
            res.add(tmp);
        }
        return res;
    }
}

```

使用链表数据结构，让操作更加方便快捷。

------



### 第4题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录





------



### 第5题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录