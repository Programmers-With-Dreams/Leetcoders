# 第三周_付清晨

本周主要是 `滑动窗口	`、`递归算法`、`分治算法`、`回溯算法` 的中等题。熟悉下各个数据结构的操作。

## I 本周目标

|   分类   |  计划完成题目  | 已完成数量 |
| :------: | :------------: | :--------: |
| 滑动窗口 | **209**，1456  |     2      |
| 递归算法 |    509，687    |     2      |
| 分治算法 |    169，53     |     0      |
| 回溯算法 | 22，78，77，46 |     0      |
|   汇总   |     共10个     |     4      |

## II 本周刷题总结

### 滑动窗口：[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/)、[定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### a. 原题描述

- 长度最小子数组：给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。
- 定长子串中元音的最大数目：给你字符串 `s` 和整数 `k` 。返回字符串 `s` 中长度为 `k` 的单个子字符串中可能包含的最大元音字母数。

#### b. 解题思路

- 长度最小子数组：

  - 滑动窗口：设置两个 `index` 分别标记子数组首尾。每次迭代 `尾 index++` ，迭代过程中与 `traget` 进行判断，并不断比较 `首index` ，看它能不能 `++` ，这样就可以得到每个 `尾index` 对应的最短子数组长度

  - **前缀和 + 二分**：为了使用二分查找，需要额外创建一个数组用于存储数组所给的前缀和。得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标，使得 $\text{sums}[\textit{bound}]-\text{sums}[i-1] \ge s$，并更新子数组的最小长度

    因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。

> Fu：这种方法虽然效率不高，但是很巧妙

- 定长子串中元音的最大数目：最普通的滑动窗口

#### c. 解题代码

 [209.长度最小的子数组.cpp](Source/209.长度最小的子数组.cpp) 

```cpp
    int minSubArrayLen(int target, vector<int>& nums) {
        auto begin = nums.begin(), end = nums.begin();
        int subSum = 0, minCount = 10001, subCount = 0;
        while (end != nums.end()) {
            subSum += *end++; ++subCount;
            int flag = subSum - target;
            if (0 <= flag) {
                while (*begin <= flag) {
                    if (begin == end) { break; }
                    subSum -= *begin++; --subCount;
                    flag = subSum - target; }
                if (subCount < minCount) { minCount = subCount; }
            }
        }
        if (minCount == 10001) { minCount = 0; }
        return minCount;
    }
```

 [1456.定长子串中元音的最大数目.cpp](Source/1456.定长子串中元音的最大数目.cpp) 

```cpp
int maxVowels(string s, int k) {
    int begin = 0, end = 0, size = s.size(), count = 0;
    for (; end < k; ++end) {
        char temp = s.at(end);
        switch (s.at(end)) { case 'a': case 'e' : case 'i' : case 'o' : case 'u' : ++count; default: break; }
    }
    int maxCount = count;
    while (end < size) {
        switch (s.at(end++)) { case 'a': case 'e' : case 'i' : case 'o' : case 'u' : ++count; default: break; }
        switch (s.at(begin++)) { case 'a': case 'e' : case 'i' : case 'o' : case 'u' : --count; default: break; }
        if (maxCount < count) { maxCount = count; }
    }
    return maxCount;
}
```

#### d. 其他解法

长度最小子数组：前缀和 + 二分

```cpp
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) { return 0; }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) { sums[i] = sums[i - 1] + nums[i - 1]; }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            if (bound != sums.end()) { ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1))); }
        }
        return ans == INT_MAX ? 0 : ans;
    }
```

### 递归算法：[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/description/)、[最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/description/)

#### a. 原题描述

- 斐波那契数：求 `Fib(n)` 

  > 这个明明是递归算法的反面例子

- 最长同值路径：给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

  **注**：两个节点之间的路径长度由它们之间的边数表示。

#### b. 解题思路

很经典的解题思路

#### c. 解题代码

 [509.斐波那契数.cpp](Source/509.斐波那契数.cpp) 

```cpp
    int fib(int n) {
        int frontFib = 0, Fib = 1, temp;
        if (!n) { return 0; }
        while (--n){ temp = frontFib; frontFib = Fib; Fib = temp + frontFib; }
        return Fib;
    }
```

 [687.最长同值路径.cpp](Source/687.最长同值路径.cpp) 

```cpp
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        max = 0; getPathByRoot(root); return max;
    }
private:
    int max;
    int getPathByRoot(TreeNode* root) {
        if (!root) { return 0; }
        int leftPath  = getPathByRoot(root->left );
        int rightPath = getPathByRoot(root->right);
        int count = 0;
        if (root->left  && root->val == root->left ->val) { count += ++leftPath; }
        else { leftPath  = 0; }
        if (root->right && root->val == root->right->val) { count += ++rightPath;}
        else { rightPath = 0; }
        if (max < count) { max = count; }
        return leftPath < rightPath ? rightPath : leftPath;
    }
};
```

### 分治算法

#### a. 原题描述

#### b. 解题思路

#### c. 解题代码

#### d. 其他解法

### 回溯算法

#### a. 原题描述

#### b. 解题思路

#### c. 解题代码

#### d. 其他解法