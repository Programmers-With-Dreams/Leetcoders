# 第三周_付清晨

本周主要是 `滑动窗口	`、`递归算法`、`分治算法`、`回溯算法` 的中等题。熟悉下各个数据结构的操作。

## I 本周目标

|   分类   |  计划完成题目  | 已完成数量 |
| :------: | :------------: | :--------: |
| 滑动窗口 | **209**，1456  |     2      |
| 递归算法 |    509，687    |     2      |
| 分治算法 |  **169，53**   |     2      |
| 回溯算法 | 22，78，77，46 |     0      |
|   汇总   |     共10个     |     6      |

## II 本周刷题总结

### 滑动窗口：[长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/description/)、[定长子串中元音的最大数目](https://leetcode-cn.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

#### a. 原题描述

- 长度最小子数组：给定一个含有 `n` 个正整数的数组和一个正整数 `target` 。找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回 `0` 。
- 定长子串中元音的最大数目：给你字符串 `s` 和整数 `k` 。返回字符串 `s` 中长度为 `k` 的单个子字符串中可能包含的最大元音字母数。

#### b. 解题思路

- 长度最小子数组：

  - 滑动窗口：设置两个 `index` 分别标记子数组首尾。每次迭代 `尾 index++` ，迭代过程中与 `traget` 进行判断，并不断比较 `首index` ，看它能不能 `++` ，这样就可以得到每个 `尾index` 对应的最短子数组长度

  - **前缀和 + 二分**：为了使用二分查找，需要额外创建一个数组用于存储数组所给的前缀和。得到前缀和之后，对于每个开始下标 i，可通过二分查找得到大于或等于 i 的最小下标，使得 $\text{sums}[\textit{bound}]-\text{sums}[i-1] \ge s$，并更新子数组的最小长度

    因为这道题保证了数组中每个元素都为正，所以前缀和一定是递增的，这一点保证了二分的正确性。如果题目没有说明数组中每个元素都为正，这里就不能使用二分来查找这个位置了。

> Fu：这种方法虽然效率不高，但是很巧妙

- 定长子串中元音的最大数目：最普通的滑动窗口

#### c. 解题代码

 [209.长度最小的子数组.cpp](Source/209.长度最小的子数组.cpp) 

```cpp
    int minSubArrayLen(int target, vector<int>& nums) {
        auto begin = nums.begin(), end = nums.begin();
        int subSum = 0, minCount = 10001, subCount = 0;
        while (end != nums.end()) {
            subSum += *end++; ++subCount;
            int flag = subSum - target;
            if (0 <= flag) {
                while (*begin <= flag) {
                    if (begin == end) { break; }
                    subSum -= *begin++; --subCount;
                    flag = subSum - target; }
                if (subCount < minCount) { minCount = subCount; }
            }
        }
        if (minCount == 10001) { minCount = 0; }
        return minCount;
    }
```

 [1456.定长子串中元音的最大数目.cpp](Source/1456.定长子串中元音的最大数目.cpp) 

```cpp
int maxVowels(string s, int k) {
    int begin = 0, end = 0, size = s.size(), count = 0;
    for (; end < k; ++end) {
        char temp = s.at(end);
        switch (s.at(end)) { case 'a': case 'e' : case 'i' : case 'o' : case 'u' : ++count; default: break; }
    }
    int maxCount = count;
    while (end < size) {
        switch (s.at(end++)) { case 'a': case 'e' : case 'i' : case 'o' : case 'u' : ++count; default: break; }
        switch (s.at(begin++)) { case 'a': case 'e' : case 'i' : case 'o' : case 'u' : --count; default: break; }
        if (maxCount < count) { maxCount = count; }
    }
    return maxCount;
}
```

#### d. 其他解法

长度最小子数组：前缀和 + 二分

```cpp
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) { return 0; }
        int ans = INT_MAX;
        vector<int> sums(n + 1, 0); 
        // 为了方便计算，令 size = n + 1 
        // sums[0] = 0 意味着前 0 个元素的前缀和为 0
        // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]
        // 以此类推
        for (int i = 1; i <= n; i++) { sums[i] = sums[i - 1] + nums[i - 1]; }
        for (int i = 1; i <= n; i++) {
            int target = s + sums[i - 1];
            auto bound = lower_bound(sums.begin(), sums.end(), target);
            if (bound != sums.end()) { ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1))); }
        }
        return ans == INT_MAX ? 0 : ans;
    }
```

### 递归算法：[斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/description/)、[最长同值路径](https://leetcode-cn.com/problems/longest-univalue-path/description/)

#### a. 原题描述

- 斐波那契数：求 `Fib(n)` 

  > 这个明明是递归算法的反面例子

- 最长同值路径：给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。

  **注**：两个节点之间的路径长度由它们之间的边数表示。

#### b. 解题思路

很经典的解题思路

#### c. 解题代码

 [509.斐波那契数.cpp](Source/509.斐波那契数.cpp) 

```cpp
    int fib(int n) {
        int frontFib = 0, Fib = 1, temp;
        if (!n) { return 0; }
        while (--n){ temp = frontFib; frontFib = Fib; Fib = temp + frontFib; }
        return Fib;
    }
```

 [687.最长同值路径.cpp](Source/687.最长同值路径.cpp) 

```cpp
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        max = 0; getPathByRoot(root); return max;
    }
private:
    int max;
    int getPathByRoot(TreeNode* root) {
        if (!root) { return 0; }
        int leftPath  = getPathByRoot(root->left );
        int rightPath = getPathByRoot(root->right);
        int count = 0;
        if (root->left  && root->val == root->left ->val) { count += ++leftPath; }
        else { leftPath  = 0; }
        if (root->right && root->val == root->right->val) { count += ++rightPath;}
        else { rightPath = 0; }
        if (max < count) { max = count; }
        return leftPath < rightPath ? rightPath : leftPath;
    }
};
```

### 分治算法：[多数元素](https://leetcode-cn.com/problems/majority-element/description/)、[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/description/)

分治就是递归嘛。这两道分治的题目都非常的有意思。

#### a. 原题描述

- 多数元素：给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。数组是非空的，并且给定的数组总是存在多数元素。

- 最大子序和：给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

#### b. 解题思路

- 多数元素：
  - hash：用hash表记录元素的数量，再找出他们中最大的
  - 排序：排序后 $\text{nums}[size/2]$ 就是多数元素
  - 递归：比较常规
  - 投票算法：这里相当于是把多数元素和非多数元素抵消掉了 https://blog.csdn.net/kimixuchen/article/details/52787307

- 最大子序和：
  - 递归：经典写法，好像是个数据结构就会这么写
  - 动态规划：用$f(i)$ 代表以第 $i$ 个数结尾的「连续子数组的最大和」，那么要求的值就是$\max(f(i))$，对于每个 $f(i)$， 有 $f(i)=\max(f(i)+\text{nums}[i],\text{nums}[i])$

#### c. 解题代码

 [169.多数元素.cpp](Source/169.多数元素.cpp) 

hash

```cpp
int majorityElement(vector<int>& nums) {
    unordered_map<int, int> count;
    int result = 0, size = nums.size();
    for (auto &item : nums){ if (++count[item] > size >> 1) { result = item; } }
    return result;
    }
```

排序

```cpp
    int majorityElement(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return nums.at(nums.size() >> 1);
    }
```

递归法

```cpp
    int majorityRec(vector<int>& nums, int left, int right) {
        if (left + 1 == right) { return nums.at(left); }
        int mid = (left + right) >> 1;
        int leftMajority = 0, rightMajority = 0, LMcount = 0, RMcount = 0;
        leftMajority = majorityRec(nums, left, mid);
        rightMajority = majorityRec(nums, mid, right);
        for (int i = left; i < right; ++i) { 
            if (nums.at(i) == leftMajority) { ++LMcount; continue; }
            if (nums.at(i) == rightMajority) { ++RMcount; continue; }
        }
        return LMcount < RMcount ? rightMajority : leftMajority;
    }

    int majorityElement(vector<int>& nums) {
        return majorityRec(nums, 0, nums.size());
    }
```

 [53.最大子序和.cpp](Source/53.最大子序和.cpp) 

迭代

```cpp
int maxSubArray(vector<int>& nums) {
    int size = nums.size(), sum = nums.at(0);
    if (size == 1) { return nums.at(0); }
    auto iter = nums.begin();
    while (iter != nums.end() && *iter < 0) { sum = sum < *iter ? *iter : sum; ++iter; }
    while (iter != nums.end()) {
        int subSum = 0;
        while (iter != nums.end() && *iter + subSum >= 0) {
            subSum += *iter++;
            if (sum < subSum) { sum = subSum; }
        }
        if (iter != nums.end()) { ++iter; }
    }
    return sum;
}
```

递归

```cpp
    int max(int a, int b, int c){
        if (a < b) { a = b; }
        if (a < c) { a = c; }
        return a;
    }
    int maxSubRec(vector<int>& nums, int left, int right) {
        if (left + 1 == right) { return nums.at(left);}
        int mid = (left + right) >> 1, leftMax = 0, rightMax = 0;
        int leftMid = 0, rightMid = 0, midMax = 0, leftMidMax = 0, rightMidMax = 0;
        leftMax = maxSubRec(nums, left, mid);
        rightMax = maxSubRec(nums, mid, right);
        if (leftMax < 0 && rightMax < 0) { return leftMax < rightMax ? rightMax : leftMax; }
        for (int i = mid - 1; i >= left; --i) {
            leftMid += nums.at(i);
            if (leftMidMax < leftMid) { leftMidMax = leftMid; }
        }
        for (int i = mid; i < right; ++i){
            rightMid += nums.at(i);
            if (rightMidMax < rightMid) { rightMidMax = rightMid; }
        }
        return max(leftMax, leftMidMax + rightMidMax, rightMax);
    }

    int maxSubArray(vector<int>& nums) {
        return maxSubRec(nums, 0, nums.size());
    }
```

#### d. 其他解法

**多数元素：投票算法**：十分巧妙，头一回遇到

```cpp
    int majorityElement(vector<int>& nums) {
        int candidate = nums.at(0), count = 0;
        for (auto &item : nums) {
            if (item == candidate) { ++count; }
            else if (--count == 0) { candidate = item; ++count; }
        }
        return candidate;
    }
};
```

**最大子序和：动态规划**：动态规划这个表达式就挺难想的。。。

```cpp
    int maxSubArray(vector<int>& nums) {
        int sum = 0, maxSum = nums.at(0);
        for (auto &item : nums) {
            sum = sum + item < item ? item : sum + item;
            maxSum = maxSum < sum ? sum : maxSum;
        }
        return maxSum;
    }
```

### 回溯算法

#### a. 原题描述

#### b. 解题思路

#### c. 解题代码

#### d. 其他解法