# 第二周_付清晨

本周主要是 `Linked List`、`Queue`、`Stack` 、`Hash Table`的简单题。熟悉下各个数据结构的操作。

## I 本周目标

|    分类     |    计划完成题目    | 已完成数量 |
| :---------: | :----------------: | :--------: |
| Linked List |      203，206      |     2      |
|    Queue    | 933，225，622，641 |     4      |
|    Stack    |    20，496，232    |     3      |
| Hash Table  |      217，389      |     2      |
|    汇总     |       共11个       |     11     |

## II 本周刷题总结

### Linked List：[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/description/)、[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/description/)

#### a. 原题陈述

两道都差不多的，一个是删除链表中等于给定值 **val** 的所有节点，一个是反转一个单链表。

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

#### b. 解题思路

由于是单向链表，需要一个 `prev` 指针，其他的迭代求解就可以了。

#### c. 解题代码  [203.移除链表元素.cpp](Source/203.移除链表元素.cpp)  [206.反转链表.cpp](Source/206.反转链表.cpp) 

```cpp
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *header = new ListNode;	// 把第一个位置保存下来，方便返回
        header->next = head;
        ListNode *prev_pointer = header, *dele_pointer = nullptr;
        while (head){
            if(head->val == val){	
                prev_pointer->next = head->next; 
                dele_pointer = head;
            }
            else{ prev_pointer = head; }
            head = head->next;
            // 以下就是后处理
            if (dele_pointer){ 
                delete dele_pointer;
                dele_pointer = nullptr; 
            }
        }
        ListNode *result = header->next;
        delete header;
        return result;
    }
```

```cpp
   ListNode* reverseList(ListNode* head) {
    	//这种方法空间复杂度上不是很好，可以不用栈用指针
        if (!head){ return nullptr; }
        stack<ListNode *> list;
        while (head){ list.push(head); head = head->next; }
        ListNode *header = list.top();
        while (true){
            ListNode *temp = list.top();
            list.pop();
            if (list.size()){ temp->next = list.top(); }
            else{ temp->next = nullptr; break; }
        }
        return header;
    }
```

#### d. 其他解法摘录

还有一种是递归解法，但是递归在这里用起来并不好，不过还是挺巧妙的。

```cpp
    ListNode* removeElements(ListNode* head, int val) {        
		if (!head){ return nullptr; }			
        head->next = removeElements(head->next, val);
        if (head->val == val){ return head->next; }
        else{ return head; }
    }
```

```cpp
    ListNode* reverseList(ListNode* head) {
        // 总感觉是变了样的迭代
        // 1>2>3>4>5
        //   ↑     ↑
        // head newHead
        if (!head || !head->next) { return head; }	// 边界条件
        ListNode* newHead = reverseList(head->next);
        // 1>2>3<4<5
        //   ↑     ↑
        // head newHead
        head->next->next = head;// 执行反转
        // 1>2<3<4<5
        //   ↑     ↑
        // head newHead
        head->next = nullptr;	// 这个是防止成环的
        // 2.next = nullptr(之前是3); 3.next = 2;
        return newHead;			// newHead指向链表第一个，递归过程中没有变化
    }
```

### Queue：[最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/description/) 

#### a. 原题陈述

前两个是队列的应用，后两个是特殊队列的设计。

- 最近的请求次数：写一个 `RecentCounter` 类来计算特定时间范围内最近的请求。实现的功能是求一个严格递增的整数流中`[最后一个数 - 3000, 最后一个数]` 这个范围内的数量。

#### b. 解题思路

- 最近的请求次数：把所有数据存入队列，每次加数据的时候就把超出范围的数据出队列，数列的长度就是请求的次数

- 用队列实现栈：用一个队列做主队列，另外一个当辅助。主队存栈的元素，辅助队列一般是空的，就在入栈的时候用一下。
  - 入栈：就是把要插入的元素先放进空队列（辅助队列），再依次把已经排好的队列（主队列）
  - 其他：这个就很简单了

- 设计循环队列、双端队列：这两个一样的。就是把数据塞进一个数组里面，设定头标志和尾标志，在插入和删除的时候更新头标志和尾标志就可以了。

#### c. 解题代码：[933.最近的请求次数.cpp](Source/933.最近的请求次数.cpp)  [225.用队列实现栈.cpp](Source/225.用队列实现栈.cpp)  [622.设计循环队列.cpp](Source/622.设计循环队列.cpp)  [641.设计循环双端队列.cpp](Source/641.设计循环双端队列.cpp) 

```cpp
class RecentCounter {
public:
    int ping(int t) {
        data.push(t);
        while (data.front() < t - 3000 ){ data.pop(); }
        return data.size();
    }
private:
    queue<int> data;
};
```

```cpp
class MyStack {
public:
    MyStack() { main_queue = new queue<int>; sub_queue = new queue<int>; }
    void push(int x) {
        sub_queue->push(x);
        size_t size = main_queue->size();
        for (size_t i = 0; i < size; i++){
            sub_queue->push(main_queue->front());
            main_queue->pop();
        }
        swap(main_queue, sub_queue);
    }
    int pop() { int temp = top(); main_queue->pop(); return temp; }
    int top() { return main_queue->front(); }
    bool empty() { return main_queue->empty(); }
private:
    queue<int> *main_queue;
    queue<int> *sub_queue;	// 这个也可以写在push函数里面
};
```

- 循环队列∈循环双端队列，这里就只放上后面那个了

```cpp
class MyCircularDeque {
public:
    MyCircularDeque(int k) {
        capacity = k; datas = new int[k];
        for (int i = 0; i < k; i++){ datas[i] = -1; }
    } 
    ~MyCircularDeque(){ delete [] datas; } 
    bool insertFront(int value) {
        if (isFull()){ return false; }
        if (!isEmpty()){ headIndex = (--headIndex + capacity) % capacity; }
        datas[headIndex] = value; ++size; return true;
    } 
    bool insertLast(int value) {
        if (isFull()){ return false; }
        if (!isEmpty()){ tailIndex = ++tailIndex % capacity; }
        datas[tailIndex] = value; ++size; return true;
    } 
    bool deleteFront() {
        if (isEmpty()){ return false; }
        datas[headIndex] = -1;	// 这里循序要注意
        if (size > 1){ headIndex = ++headIndex % capacity; }
        --size; return true;
    } 
    bool deleteLast() {
        if (isEmpty()){ return false; }
        datas[tailIndex] = -1;
        if (size > 1){ tailIndex = (--tailIndex + capacity) % capacity; }
        --size;
        return true;
    } 
    int getFront() { return datas[headIndex]; } 
    int getRear() { return datas[tailIndex]; } 
    bool isEmpty() { return !size; } 
    bool isFull() { return size == capacity; } 
private:
    int *datas;
    int size = 0, capacity, headIndex = 0, tailIndex = 0;
};
```

### Stack：[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/description/) [下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/description/) [用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/description/) 

#### a. 原题陈述

这几个全是应用了。

- 有效的括号：给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。
- 下一个更大元素I：给定两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，其中`nums1` 是 `nums2` 的子集，找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值（ `x` 在 `nums2` 中对应位置的右边的第一个比 `x` 大的元素。如果不存在，对应位置输出 `-1` 。）

#### b. 解题思路

中间这个挺难的，想了半天还是写的暴力法，其他两道蛮简单。

#### c. 解题代码： [20.有效的括号.cpp](Source/20.有效的括号.cpp)  [496.下一个更大元素-i.cpp](Source/496.下一个更大元素-i.cpp)  [232.用栈实现队列.cpp](Source/232.用栈实现队列.cpp) 

```cpp
    bool isValid(string s) {
        stack<char> data;
        for (auto &c : s){
            if (data.empty()){ data.push(c); continue; }
            char top = data.top();
            if ((top == '(' && c == ')') || 
                (top == '{' && c == '}') ||
                (top == '[' && c == ']')){ data.pop(); }
            else{ data.push(c); } 
        }
        return data.empty();
    }
```

```cpp
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> result_vector;
        for (auto iter1 = nums1.begin(); iter1 != nums1.end(); ++iter1){
            auto iter2 = find_if(
                find(nums2.cbegin(), nums2.cend(), *iter1), 
                nums2.cend(),
                [iter1](const int num){ return *iter1 < num; });
            if (iter2 == nums2.end()){ result.push_back(-1); }
            else{ result.push_back(*iter2); }
        }
        return result;
    }
```

```cpp
class MyQueue {
public:
    void push(int x) {
        stack<int> temp;
        while (!datas.empty()){ temp.push(datas.top()); datas.pop(); }
        temp.push(x);
        while (!temp.empty()){ datas.push(temp.top()); temp.pop(); }        
    }
    int pop() { int temp = datas.top(); datas.pop(); return temp; }
    int peek() { return datas.top(); }
    bool empty() { return datas.empty(); }
private:
    stack<int> datas;
};
```

#### d. 其他解法摘录

第496题，首先遍历第二个数组，把每个对应的元素下一个最大值写出来，储存在 `map` 中，然后遍历第一个数组用 `map[nums1.item]` 找出最大的，可以实现 $O(\text{nums1}.size()+\text{nums2}.size())$ 的复杂度。

```cpp
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> result_vector;
        stack<int> temp_stack;
        map<int, int> result_map;
        for (auto iter = nums2.begin(); iter != nums2.end(); ++iter){
            // iter -> value, stack -> key, 这里面的是整题的关键代码
            while (!temp_stack.empty() && temp_stack.top() < *iter){
                result_map[temp_stack.top()] = *iter;
                temp_stack.pop();
            }	// 栈内的数都是比*iter大的数
            temp_stack.push(*iter);
        }
        while (!temp_stack.empty()){	// 没找到更大的数，就留在了栈中
            result_map[temp_stack.top()] = -1; 
            temp_stack.pop();
        }        
        // 后处理
        for (auto iter = nums1.begin(); iter != nums1.end(); ++iter){
            result_vector.push_back(result_map[*iter]);
        }
        return result_vector;
    }
```

### Hash Table：[存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/description/) [找不同](https://leetcode-cn.com/problems/find-the-difference/description/)

这一块的题目用关联容器求解都不是最优解。。。

#### a. 原题陈述

第一个判断字符串中是否有不同的元素，第二个是找出两个只差一个字符的两个字符串中那个不同的字符。

#### b. 解题思路

- 存在重复元素：
  - 把数据存到关联容器中，存的时候判断是否有重复的。时间复杂度 $O(N)$ ，空间复杂度 $O(N)$
  - 把数据排序，然后去重。如果返回不是为迭代器说明有重复的。时间复杂度 $O(N\lg N)$，空间复杂度 $O(\lg N)$
  > 第二种要好些，不过我没想到

- 找不同：
  - 把数据存到关联数组中，再一个个删掉
  
  - 两个字符串字符ACSII加起来再相减
  
    > 这个也很巧妙
  
  - 所有元素按位 `^` 就可以找出不同的元素
  
    > 位运算，永远的神

#### c. 解题代码

```cpp
    char findTheDifference(string s, string t) {
        unordered_multiset<int> datas;
        for (auto &c : s){ datas.insert(c); }
        for (auto &c : t){
            auto iter = datas.find(c);
            if (iter == datas.cend()){ return c; }
            datas.erase(iter);
        }
        return *datas.begin();
    }
```

```cpp
    bool containsDuplicate(vector<int>& nums) {
        unordered_set<int> data;
        for (auto iter = nums.begin(); iter != nums.end(); ++iter){
            if (data.find(*iter) != data.end()){ return true; }
            data.insert(*iter);
        }
        return false;
    }
```

#### d. 其他解法摘录

```cpp
    char findTheDifference(string s, string t) {
        char result = 0; 
        for (auto &c : s + t){ result ^= c; }	// a ^ a = 0
        return result;
    }
```

```cpp
	bool containsDuplicate(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        return unique(nums.begin(), nums.end()) == nums.end() ? false : true;
    }
```

