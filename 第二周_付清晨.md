# 第二周_付清晨

本周主要是 `Linked List`、`Queue`、`Stack` 、`Hash Table`的简单题。

## I 本周目标

|    分类     |    计划完成题目    | 已完成数量 |
| :---------: | :----------------: | :--------: |
| Linked List |      203，206      |     2      |
|    Queue    | 933，225，622，641 |     0      |
|    Stack    |    20，496，232    |     0      |
| Hash Table  |   217，389，496    |     0      |
|    汇总     |       共12个       |     1      |

## II 本周刷题总结

### Linked List：[移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/description/)、[反转链表](https://leetcode-cn.com/problems/reverse-linked-list/description/)

#### a. 原题陈述

两道都差不多的，一个是删除链表中等于给定值 **val** 的所有节点，一个是反转一个单链表。

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

#### b. 解题思路

由于是单向链表，需要一个 `prev` 指针，其他的迭代求解就可以了。

#### c. 解题代码  [203.移除链表元素.cpp](Source/203.移除链表元素.cpp)  [206.反转链表.cpp](Source\206.反转链表.cpp) 

```cpp
    ListNode* removeElements(ListNode* head, int val) {
        ListNode *header = new ListNode;	// 把第一个位置保存下来，方便返回
        header->next = head;
        ListNode *prev_pointer = header, *dele_pointer = nullptr;
        while (head){
            if(head->val == val){	
                prev_pointer->next = head->next; 
                dele_pointer = head;
            }
            else{ prev_pointer = head; }
            head = head->next;
            // 以下就是后处理
            if (dele_pointer){ 
                delete dele_pointer;
                dele_pointer = nullptr; 
            }
        }
        ListNode *result = header->next;
        delete header;
        return result;
    }
```

```cpp
   ListNode* reverseList(ListNode* head) {
    	//这种方法空间复杂度上不是很好，可以不用栈用指针
        if (!head){ return nullptr; }
        stack<ListNode *> list;
        while (head){ list.push(head); head = head->next; }
        ListNode *header = list.top();
        while (true){
            ListNode *temp = list.top();
            list.pop();
            if (list.size()){ temp->next = list.top(); }
            else{ temp->next = nullptr; break; }
        }
        return header;
    }
```

#### d. 其他解法摘录

还有一种是递归解法，但是递归在这里用起来并不好，不过还是挺巧妙的。

```cpp
    ListNode* removeElements(ListNode* head, int val) {        
		if (!head){ return nullptr; }			
        head->next = removeElements(head->next, val);
        if (head->val == val){ return head->next; }
        else{ return head; }
    }
```

```cpp
    ListNode* reverseList(ListNode* head) {
        // 总感觉是变了样的迭代
        // 1>2>3>4>5
        //   ↑     ↑
        // head newHead
        if (!head || !head->next) { return head; }	// 边界条件
        ListNode* newHead = reverseList(head->next);
        // 1>2>3<4<5
        //   ↑     ↑
        // head newHead
        head->next->next = head;// 执行反转
        // 1>2<3<4<5
        //   ↑     ↑
        // head newHead
        head->next = nullptr;	// 这个是防止成环的
        // 2.next = nullptr(之前是3); 3.next = 2;
        return newHead;			// newHead指向链表第一个，递归过程中没有变化
    }
```

### Queue

### Stack

### Hash Table
