# 第五周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   4    |   15   | 26.67% |

## II 本周刷题总结

### 第1题 [两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

难度：简单

类型：链表

方法：数学处理

#### a. 原题陈述

输入两个链表，找出它们的第一个公共节点。

#### b. 解题思路

充分利用交叉节点的特点，两轮遍历必同归

#### c. 解题代码

HashMap，效率不高

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 1. 初始化
        Map<Integer,ArrayList<ListNode>> dic = new HashMap<>();
        ListNode cur_A = headA;
        ListNode cur_B = headB;
        // 2. 遍历填充HashMap
        while(cur_A!=null){
            if(dic.containsKey(cur_A.val)){
                dic.get(cur_A.val).add(cur_A);
            }else{
                ArrayList<ListNode> tmp= new ArrayList<>();
                tmp.add(cur_A);
                dic.put(cur_A.val,tmp);
            }
            cur_A = cur_A.next;
        }
        // 3. 遍历，如果值相等，判断第一个节点是不是与cur_B相等
        while(cur_B!=null){
            if(dic.containsKey(cur_B.val)){
                // 值相等，返回ArrayList
                ArrayList<ListNode> tmp = dic.get(cur_B.val);
                if(tmp!=null){
                    if(tmp.get(0)==cur_B)
                        return cur_B;
                    else
                        tmp.remove(0);
                }

            }
            cur_B = cur_B.next;
        }
        // 4. 返回值
        return null;
    }
}
```

#### d. 其他解法摘录

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A= headA, B = headB;
        while(A!=B){
            A = A==null ? headB:A.next;
            B = B==null ? headA:B.next;
        }
        return A;
    }
}
```



------



### 第2题 [在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

难度：简单

类型：排序数组

方法：二分法

#### a. 原题陈述

统计一个数字在排序数组中出现的次数。

#### b. 解题思路

二分法找边界

#### c. 解题代码

效率不高

```java
class Solution {
    public int search(int[] nums, int target) {
        // 1. 初始化
        Map<Integer, Integer> times = new HashMap<>();
        // 2. 遍历填充HashMap
        for(int i = 0; i < nums.length; ++i){
            if(times.containsKey(nums[i])){
                times.put(nums[i],times.get(nums[i])+1);
            }
            else
                times.put(nums[i],1);
        }
        // 3. 查找target，并返回值
        if(times.containsKey(target))
            return times.get(target);
        else
            return 0 ;
    }
}
```

#### d. 其他解法摘录

效率贼高，要审题与发挥想象力

```java
class Solution {
    public int search(int[] nums, int target) {
        return helper(nums,target)-helper(nums,target-1);
    }
    // 找右边界
    public int helper(int[] nums, int tar){
        int i = 0, j = nums.length - 1;
        while(i<=j){
            int m = (i+j)/2;
            if(nums[m]<=tar) i = m+1;
            else j = m-1;
        }
        return i;
    }
}
```



------



### 第3[0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

难度：简单

类型：有序数组

方法：二分法

#### a. 原题陈述

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

#### b. 解题思路

优雅的二分法

#### c. 解题代码

```java
class Solution {
    public int missingNumber(int[] nums) {
        // 二分法
        int left = 0, right = nums.length - 1;;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] != mid) 
                right = mid - 1;
            else    
                left = mid + 1;
        }
        return left;

    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int missingNumber(int[] nums) {
        // 和数相减
        int sum = nums.length*(nums.length + 1)/2;
        return sum - Arrays.stream(nums).sum();

    }
}
```



------



### 第4题 [二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

难度：简单

类型：树

方法：中序遍历

#### a. 原题陈述

给定一棵二叉搜索树，请找出其中第k大的节点。

#### b. 解题思路

逆中序遍历的新世界，贼强！

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    ArrayList<Integer> res = new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        // 中序遍历
        recur(root, k);
        // return res.get(res.size()-k);
        return res.get(0);
    }
    void recur(TreeNode root, int k){
        if(root == null) return;
        // 左节点
        recur(root.left,k);
        // 当前节点处理
        if(res.size() < k){
            res.add(root.val);
        }else if(res.size() == k){
            res.remove(0);
            res.add(root.val);
        }
        // res.add(root.val);
        // 右节点
        recur(root.right,k);
    }
}
```

#### d. 其他解法摘录

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int k,res;
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        // 逆向中序遍历
        recur(root);
        return res;
    }
    void recur(TreeNode root){
        if(root == null) return;
        // 右节点
        recur(root.right);
        // 当前节点处理
        if(k==0) return;
        if(--k==0) res = root.val;
        // 左节点
        recur(root.left);
    }
}
```



------



### 第5题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第6题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第7题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第8题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第9题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第10题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第11题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第12题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第13题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第14题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第15题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



