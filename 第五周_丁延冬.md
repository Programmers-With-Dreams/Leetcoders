# 第五周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   4    |   15   | 26.67% |

## II 本周刷题总结

### 第1题 [两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

难度：简单

类型：链表

方法：数学处理

#### a. 原题陈述

输入两个链表，找出它们的第一个公共节点。

#### b. 解题思路

充分利用交叉节点的特点，两轮遍历必同归

#### c. 解题代码

HashMap，效率不高

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        // 1. 初始化
        Map<Integer,ArrayList<ListNode>> dic = new HashMap<>();
        ListNode cur_A = headA;
        ListNode cur_B = headB;
        // 2. 遍历填充HashMap
        while(cur_A!=null){
            if(dic.containsKey(cur_A.val)){
                dic.get(cur_A.val).add(cur_A);
            }else{
                ArrayList<ListNode> tmp= new ArrayList<>();
                tmp.add(cur_A);
                dic.put(cur_A.val,tmp);
            }
            cur_A = cur_A.next;
        }
        // 3. 遍历，如果值相等，判断第一个节点是不是与cur_B相等
        while(cur_B!=null){
            if(dic.containsKey(cur_B.val)){
                // 值相等，返回ArrayList
                ArrayList<ListNode> tmp = dic.get(cur_B.val);
                if(tmp!=null){
                    if(tmp.get(0)==cur_B)
                        return cur_B;
                    else
                        tmp.remove(0);
                }

            }
            cur_B = cur_B.next;
        }
        // 4. 返回值
        return null;
    }
}
```

#### d. 其他解法摘录

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A= headA, B = headB;
        while(A!=B){
            A = A==null ? headB:A.next;
            B = B==null ? headA:B.next;
        }
        return A;
    }
}
```



------



### 第2题 [在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

难度：简单

类型：排序数组

方法：二分法

#### a. 原题陈述

统计一个数字在排序数组中出现的次数。

#### b. 解题思路

二分法找边界

#### c. 解题代码

效率不高

```java
class Solution {
    public int search(int[] nums, int target) {
        // 1. 初始化
        Map<Integer, Integer> times = new HashMap<>();
        // 2. 遍历填充HashMap
        for(int i = 0; i < nums.length; ++i){
            if(times.containsKey(nums[i])){
                times.put(nums[i],times.get(nums[i])+1);
            }
            else
                times.put(nums[i],1);
        }
        // 3. 查找target，并返回值
        if(times.containsKey(target))
            return times.get(target);
        else
            return 0 ;
    }
}
```

#### d. 其他解法摘录

效率贼高，要审题与发挥想象力

```java
class Solution {
    public int search(int[] nums, int target) {
        return helper(nums,target)-helper(nums,target-1);
    }
    // 找右边界
    public int helper(int[] nums, int tar){
        int i = 0, j = nums.length - 1;
        while(i<=j){
            int m = (i+j)/2;
            if(nums[m]<=tar) i = m+1;
            else j = m-1;
        }
        return i;
    }
}
```



------



### 第3[0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

难度：简单

类型：有序数组

方法：二分法

#### a. 原题陈述

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

#### b. 解题思路

优雅的二分法

#### c. 解题代码

```java
class Solution {
    public int missingNumber(int[] nums) {
        // 二分法
        int left = 0, right = nums.length - 1;;
        while(left <= right){
            int mid = (left + right)/2;
            if(nums[mid] != mid) 
                right = mid - 1;
            else    
                left = mid + 1;
        }
        return left;

    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int missingNumber(int[] nums) {
        // 和数相减
        int sum = nums.length*(nums.length + 1)/2;
        return sum - Arrays.stream(nums).sum();

    }
}
```



------



### 第4题 [二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

难度：简单

类型：树

方法：中序遍历

#### a. 原题陈述

给定一棵二叉搜索树，请找出其中第k大的节点。

#### b. 解题思路

逆中序遍历的新世界，贼强！

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    ArrayList<Integer> res = new ArrayList<>();
    public int kthLargest(TreeNode root, int k) {
        // 中序遍历
        recur(root, k);
        // return res.get(res.size()-k);
        return res.get(0);
    }
    void recur(TreeNode root, int k){
        if(root == null) return;
        // 左节点
        recur(root.left,k);
        // 当前节点处理
        if(res.size() < k){
            res.add(root.val);
        }else if(res.size() == k){
            res.remove(0);
            res.add(root.val);
        }
        // res.add(root.val);
        // 右节点
        recur(root.right,k);
    }
}
```

#### d. 其他解法摘录

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int k,res;
    public int kthLargest(TreeNode root, int k) {
        this.k = k;
        // 逆向中序遍历
        recur(root);
        return res;
    }
    void recur(TreeNode root){
        if(root == null) return;
        // 右节点
        recur(root.right);
        // 当前节点处理
        if(k==0) return;
        if(--k==0) res = root.val;
        // 左节点
        recur(root.left);
    }
}
```



------



### 第5题 [二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

难度：简单

类型：树

方法：先序遍历

#### a. 原题陈述

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

#### b. 解题思路

先序遍历

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int max = 0,cur = 0;
    public int maxDepth(TreeNode root) {
        recur(root);
        return max;
    }
    void recur(TreeNode root){
        if(root == null) return;
        cur++;
        setMax();
        // 左子节点
        recur(root.left);
        // 只有当节点不为null的时候，才会自加
        if(root.left != null) cur--;
        // 右子节点
        recur(root.right);
        if(root.right != null) cur--;

    }
    // max更新函数
    void setMax(){
        if(max < cur){
            max = cur;
        }
    }
}
```

#### d. 其他解法摘录

先序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // int max = 0,cur = 0;
    public int maxDepth(TreeNode root) {
        // 后序遍历
        if(root==null) return 0;
        return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
    }
}
```



------



### 第6题 [平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

难度：简单

类型：树

方法：遍历

#### a. 原题陈述

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

#### b. 解题思路

先序遍历+判断

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // 平衡二叉树标志，最初设为true
    boolean isBalanced = true;
    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return isBalanced;
    }
    public int maxDepth(TreeNode root){
        if(root == null) return 0;
        int n_left = maxDepth(root.left);
        int n_right = maxDepth(root.right);
        // 增加判断条件
        if( n_left - n_right > 1 || n_right - n_left > 1 ) isBalanced = false;
        return Math.max(n_left,n_right) + 1;
    }
}

// 优雅版本
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) return true;
        return Math.abs(depth(root.left) - depth(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }

    private int depth(TreeNode root) {
        if (root == null) return 0;
        return Math.max(depth(root.left), depth(root.right)) + 1;
    }
}
```

#### d. 其他解法摘录

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {

    public boolean isBalanced(TreeNode root) {
        return recur(root)!=-1;
    }
    private int recur(TreeNode root){
        if(root==null) return 0;
        int left = recur(root.left);
        // 提前返回，减枝
        if(left == -1) return -1;
        int right = recur(root.right);
        if(right == -1) return -1;
        return Math.abs(left-right) < 2? Math.max(left,right)+1:-1;
    }

}
```



------



### 第7题 [数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

难度：中等

类型：数组

方法：位运算

#### a. 原题陈述

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

#### b. 解题思路

位运算适合类型为重复的题

#### c. 解题代码

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        // 1. 初始化
        int a = 0,m = 1,x = 0, y = 0;
        // 2. 遍历异或
        for(int num:nums)
            a ^= num;
        // 3. 找出a中1位
        while((a&m) == 0 )
            m <<= 1;
        // 4. 拆分nums与做异或
        for(int num : nums){
            if((num & m) != 0) x ^= num;
            else y ^= num;
        }
        return new int[] {x,y};
    }
}
```

#### d. 其他解法摘录

二分法

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int sum = 0, min = Integer.MAX_VALUE, max = Integer.MIN_VALUE, zeroCount = 0;
        for (int num: nums) {
            if (num == 0) {
                zeroCount += 1;
            }
            min = Math.min(min, num);
            max = Math.max(max, num);
            sum ^= num;
        }
        // 需要特判一下某个数是0的情况。
        if (zeroCount == 1) {
            return new int[]{sum, 0};
        }
        int lo = min, hi = max;
        while (lo <= hi) {
            // 根据 lo 的正负性来判断二分位置怎么写，防止越界。
            int mid = (lo < 0 && hi > 0)? (lo + hi) >> 1: lo + (hi - lo) / 2;
            int loSum = 0, hiSum = 0;
            for (int num: nums) {
                if (num <= mid) {
                    loSum ^= num;
                } else {
                    hiSum ^= num;
                }
            }
            if (loSum != 0 && hiSum != 0) {
                // 两个都不为0，说明 p 和 q 分别落到2个数组里了。
                return new int[] {loSum, hiSum};
            }
            if (loSum == 0) {
                // 说明 p 和 q 都比 mid 大，所以比 mid 小的数的异或和变为0了。
                lo = mid + 1;
            } else {
                // 说明 p 和 q 都不超过 mid
                hi = mid - 1;
            }
        }
        // 其实如果输入是符合要求的，程序不会执行到这里，为了防止compile error加一下
        return null;
    }
}
```



------



### 第8题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第9题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第10题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第11题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第12题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第13题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第14题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



### 第15题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```



------



