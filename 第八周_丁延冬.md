# 第八周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   2    |   14   |        |

## II 本周刷题总结



### 第1题 [平方数之和](https://leetcode-cn.com/problems/sum-of-square-numbers/)

难度：中等

方法：双指针

#### a. 原题陈述

给定一个非负整数 `c` ，你要判断是否存在两个整数 `a` 和 `b`，使得 `a2 + b2 = c` 。

#### b. 解题思路

双指针逐个扫描

#### c. 解题代码

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        int i = 0, j = (int)Math.floor(Math.sqrt(c));// 滑动双指针
        // int i = 0, j = (c+1)/2+1;// 滑动双指针
        while( i <= j ){// 运行条件
            int total = i*i+ j*j;
            if(total < c)
                i++;
            else if(total > c)
                j--;
            else
                return true;
        }
        return false;
    }
}
```

#### d. 其他解法摘录

```java

```

---

### 第2题 [x 的平方根](https://leetcode-cn.com/problems/sqrtx/)

难度：简单

方法：二分法

#### a. 原题陈述

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

#### b. 解题思路

二分法变形

#### c. 解题代码

```java
class Solution {
    public int mySqrt(int x) {
        int i = 0, j = x;
        while(i < j){
                        /*
            这里为什么使用的是 (left + right + 1) >>> 1 ， 而不是跟之前一样使用 (left + right) >>> 1 ？
            因为我们下面需要的是 right = mid - 1 而不是 left = mid + 1，如果 (left + right) >>> 1 的话 left = mid 可能会造成死循环

            为什么使用 right = mid - 1？
            在不存在 一个整数平方等于 x 的情况下，比如 x = 8，有以下情况：
            因为我们要求的是 相邻的两个数 x1 和 x2 ，x1 的平方比 x 小， x2 的平方比 x 大
            比如 x = 8，那么 x1 = 2, x2 = 3
            而我们需要返回的是 x1 = 2，即较小的值，因此，当我们遇到大值的时候，需要跳过该大值，往小值方向找
            与以往的跳过小值，找大值不同
            如果是以往的二分查找模板，那么当 break 找到的就会是 x2 = 3
            */
            int m = (i+j+1)>>>1;
            if(x/m<m)
                j = m-1;
            else
                i = m;
        }
        return i;
    }
}
```

#### d. 其他解法摘录

```java

```

---

### 第3题 [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

难度：中等

方法：二分法

#### a. 原题陈述

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

#### b. 解题思路

通过细节调整完成两个端点的寻找

#### c. 解题代码

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int start = -1, end = -1;
        int l = 0, r = nums.length-1;// 左闭右闭
        while(l<=r){
            int mid = (l+r)>>1;//　寻找数字，普通除以二
            if(target < nums[mid])
                r = mid - 1;
            else if(target > nums[mid])
                l = mid + 1;
            else{
                int tmp = mid, tmp1 = mid;
                start = mid;
                end = mid;
                while(--tmp >= 0 && nums[tmp]==target) start--;// 确定start
                while(++tmp1 < nums.length && nums[tmp1]==target) end++;// 确定end
                break;
            }
        }
        return new int[]{start,end};
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int leftIdx = binarySearch(nums, target, true);
        int rightIdx = binarySearch(nums, target, false) - 1;
        if (leftIdx <= rightIdx && rightIdx < nums.length && nums[leftIdx] == target && nums[rightIdx] == target) {
            return new int[]{leftIdx, rightIdx};
        } 
        return new int[]{-1, -1};
    }

    public int binarySearch(int[] nums, int target, boolean lower) {
        int left = 0, right = nums.length - 1, ans = nums.length;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target || (lower && nums[mid] >= target)) {// 寻找第一个大于target或者第一个大于等于target的索引
                right = mid - 1;
                ans = mid;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }
}
```

---

### 第4题 [搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

难度：中等

方法：二分法

#### a. 原题陈述

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。

编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。

#### b. 解题思路

二分法

#### c. 解题代码

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int l = 0, r = nums.length - 1, m;
        while( l <= r ){
            m = ( l + r ) / 2;
            if(nums[m] == target)
                return true;
            if(nums[l] == nums[m])
                ++l;
            else if(nums[m] <= nums[r]){
                // 右区间是增序的
                if(target > nums[m] && target <= nums[r]){
                    l = m + 1;
                }else{
                    r = m - 1;
                }
            }else{
                // 左区间是增序的
                if(target >= nums[l] && target < nums[m]){
                    r = m - 1;
                }else{
                    l = m + 1;
                }
            }
        }
        return false;
    }
}
```

#### d. 其他解法摘录

```java

```

---

### 第5题 [寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

难度：困难

方法：二分法

#### a. 原题陈述

假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

#### b. 解题思路

二分法

#### c. 解题代码

```java
class Solution {
    public int findMin(int[] nums) {
        int l = 0, r = nums.length - 1, m;
        while( l < r ){
            m = (l + r)>>1;
            if(nums[m] > nums[r])
                l = m + 1;
            else if(nums[m] < nums[r])
                r = m;
            else
                r--;
        }
        return nums[l];
    }
}
```

#### d. 其他解法摘录

```java

```

---

### 第6题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第7题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第8题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第9题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第10题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第11题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第12题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第13题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第14题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

