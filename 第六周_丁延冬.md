# 第五周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   7    |   14   |  50%   |

## II 本周刷题总结

### 第1题 [翻转单词顺序](https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

难度：简单

类型：字符串

方法：切片法

#### a. 原题陈述

输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串"I am a student. "，则输出"student. a am I"。

#### b. 解题思路

切片法

#### c. 解题代码

```java
class Solution {
    public String reverseWords(String s) {
        StringBuilder res = new StringBuilder();
        String[] strs = s.trim().split(" ");
        for(int i = strs.length - 1; i >= 0; i--){
            if(strs[i].equals("")) continue;
            res.append(strs[i]+" ");
        }
        return res.toString().trim();
    }
}
```

#### d. 其他解法摘录

```java

```

---

### 第2题 [左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

难度：简单

类型：字符串

方法：切割法

#### a. 原题陈述

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

#### b. 解题思路

切片法

#### c. 解题代码

切片法

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        String str0 = new String();
        String str1 = new String();
        str0 = s.substring(0,n);
        str1 = s.substring(n,s.length());
        return str1 + str0;
    }
}
```

#### d. 其他解法摘录

求余append

```java
class Solution {
    public String reverseLeftWords(String s, int n) {
        StringBuilder res = new StringBuilder();
        for(int i = n; i < n + s.length(); i++)
            res.append(s.charAt(i % s.length()));
        return res.toString();
    }
}
```

---

### 第3题 [滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

难度：简单

类型：双指针

方法：优先级队列

#### a. 原题陈述

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

#### b. 解题思路

优先级队列（慢）

#### c. 解题代码

巨慢法

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length==0 || nums == null) return new int[0];
        int[] res = new int[nums.length-k+1];
        PriorityQueue<Integer> queue = new PriorityQueue<Integer>(new Comparator<Integer>(){
            public int compare(Integer num1, Integer num2){
                return num2 - num1;// 大堆
            }
        });
        int i = 0, j = 0, x = 0;

        while(j < nums.length){
            queue.add(nums[j++]);
            if( j - i == k ){// 此时滑动数组的长度满足k
                res[x++] = queue.peek();
                queue.remove(nums[i++]);
            }
        }

        return res;
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0 || k == 0) return new int[0];
        Deque<Integer> deque = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];
        for(int j = 0, i = 1 - k; j < nums.length; i++, j++) {
            // 删除 deque 中对应的 nums[i-1]
            if(i > 0 && deque.peekFirst() == nums[i - 1])
                deque.removeFirst();
            // 保持 deque 递减
            while(!deque.isEmpty() && deque.peekLast() < nums[j])
                deque.removeLast();
            deque.addLast(nums[j]);
            // 记录窗口最大值
            if(i >= 0)
                res[i] = deque.peekFirst();
        }
        return res;
    }
}
```

---

### 第4题 [队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

难度：中等

类型：队列

方法：辅助队列

#### a. 原题陈述

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

#### b. 解题思路

构造两个队列，一个负责存储，另一个负责存储最大值

#### c. 解题代码

```java
class MaxQueue {
    Deque<Integer> deque1;
    Deque<Integer> deque2;

    public MaxQueue() {
        deque1 = new ArrayDeque<>();// 初始化队列
        deque2 = new ArrayDeque<>();// 初始化队列
    }
    
    public int max_value() {
        if(!deque2.isEmpty())
            return deque2.peekFirst();
        else
            return -1;
    }
    
    public void push_back(int value) {
        deque1.addLast(value);
        while((!deque2.isEmpty())&&(deque2.peekLast() < value)) deque2.removeLast();// 从后往前，小于value则删除
        deque2.addLast(value);
    }
    
    public int pop_front() {
        if(!deque1.isEmpty()){
            int tmp = deque1.removeFirst();
            if(tmp == deque2.peekFirst()) 
                deque2.removeFirst();
            return tmp;
        }else{
            return -1;
        }
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```

#### d. 其他解法摘录

```java

```

---

### 第5题 [n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

难度：中等

类型：生活

方法：动态规划

#### a. 原题陈述

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

#### b. 解题思路

动态规划

找准转移方程并简化

#### c. 解题代码

```java
class Solution {
    public double[] dicesProbability(int n) {
        // 初始化
        double[] dp = new double[6];
        Arrays.fill(dp,1.0/6.0);
        // 动态规划
        for(int i = 2; i < n + 1; i++){
            double[] tmp = new double[5*i+1];
            for(int j = 0; j < dp.length; j++){
                for(int k = 0; k < 6; k++){
                    tmp[j+k] += dp[j]/6.0;
                }
            }
            dp = tmp;
        }
        return dp;
    }
}
```

#### d. 其他解法摘录

```java

```

---

### 第6题 [扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

难度：简单

类型：生活

方法：建模简化

#### a. 原题陈述

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

#### b. 解题思路

找到规律，建模简化

#### c. 解题代码

```java
class Solution {
    public boolean isStraight(int[] nums) {
        // 扫描找到最大最小值，有无重复值，零的个数
        int max = 0, min = 14;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0){
                continue;
            }else{
                if(max < nums[i])
                    max = nums[i];
                if(min > nums[i])
                    min = nums[i];
                for(int j = i + 1; j < nums.length; j++){// 判断有无重复值
                    if(nums[j] == nums[i]){
                        return false;
                    }
                    
                }
            }
        }
        if(max-min <= 4) 
            return true;
        return false;
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public boolean isStraight(int[] nums) {
        int joker = 0;
        Arrays.sort(nums); // 数组排序
        for(int i = 0; i < 4; i++) {
            if(nums[i] == 0) joker++; // 统计大小王数量
            else if(nums[i] == nums[i + 1]) return false; // 若有重复，提前返回 false
        }
        return nums[4] - nums[joker] < 5; // 最大牌 - 最小牌 < 5 则可构成顺子
    }
}
```

---

### 第7题 [圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

难度：简单

类型：数学

方法：取模法

#### a. 原题陈述

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

#### b. 解题思路

链表模拟不可行

取模循环，善用Array List

#### c. 解题代码

```java
class Solution {
    public int lastRemaining(int n, int m) {
        ArrayList<Integer> list = new ArrayList<>();
        for(int i = 0; i < n; i++){
            list.add(i);
        }
        int idx = 0;
        while(n>1){
            idx = (idx+m-1)%n;// 取模实现循环
            list.remove(idx);// ArrayList删除元素之后，后位自动填充前位序号
            n--;
        }
        return list.get(0);
    }
    
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}
```

---

### 第8题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第9题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第10题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第11题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第12题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第13题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第14题 

难度：

类型：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

