# 第六周_付清晨

本周主要是 `并查集` 、`贪心算法` 的中等题。

## I 本周目标


|           分类            | 计划完成题目  | 已完成数量 |
| :-----------------------: | :-----------: | :--------: |
|          并查集           | 200，547，721 |     3      |
| 阿里实习笔试（3月15日场） |     1，2      |     1      |
| 阿里实习笔试（3月19日场） |     1，2      |     1      |
| 字节实习笔试（3月21日场） |  1，2，3，4   |     2      |
|           汇总            |     共6个     |     6      |

> - 200题是上周刚写过的，这周就不算在内了
> - 实习笔试的【计划完成题目】是总的题目数，不是目标，汇总的计划完成题目是上周定下的目标

## II 本周刷题总结

### 回溯算法

学起来容易用起来难啊。。。

|  题目   | 难度 |                             描述                             |
| :-----: | :--: | :----------------------------------------------------------: |
|   200   | 中等 |   给定由 `'1'陆`和 `'0'水`组成的网格，计算网格中岛屿的数量   |
|   547   | 中等 | 有 `n` 个城市。若 `a` 与 `b` 相连， `b` 与 `c` 相连，那么`a` 与 `c` 相连。**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。返回矩阵中 **省份** 的数量。 |
| **721** | 中等 | 给定一个列表 `accounts`，其中第一个元素 `accounts[i][0]` 是名称，其余元素是该账户的邮箱地址。我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。 |

#### 547：[省份数量](https://leetcode-cn.com/problems/number-of-provinces/description/)

- 解题思路：

  - 常规并查集操作
  
  ```cpp
      int getRoot(vector<int> &parent, int index) {
          while(parent[index] != -1){ index = parent[index]; }
          return index;
      }
    void unionGraph(vector<int> &parent, vector<int> &layout,  int i, int j) {
          int i_root = getRoot(parent, i), j_root = getRoot(parent, j);
          if (i_root == j_root && i_root != -1) { return; }
          if (layout[i_root] < layout[j_root]) { parent[i_root] = j_root; }
        else if (layout[j_root] < layout[i_root]) { parent[j_root] = i_root; }
          else { parent[i_root] = j_root; ++layout[j_root]; }       
      }
      int findCircleNum(vector<vector<int>>& isConnected) {
          int size = isConnected.size(), count = 0;
          vector<int> parent, layout;
          for (int i = 0; i < size; ++i) { 
              parent.push_back(-1); layout.push_back(0); }
          for (int i = 0; i < size; ++i) { for (int j = i + 1; j < size; ++j) { 
              if (isConnected[i][j] == 1) { unionGraph(parent, layout, i, j); } } }
          for (auto &item : parent) { if (item == -1) { ++count; } }
          return count;
      }
  ```
  
  - DFS
  
  ```cpp
      int findCircleNum(vector<vector<int>>& isConnected) {
          stack<int> graphStack;
          size_t size = isConnected.size(), count = 0;
          vector<bool> isVisited(size, false);
          for (size_t i = 0; i < size; ++i) {
              if (isVisited.at(i)) { continue; }
              ++count;
              graphStack.push(i); // 看了好久找出的 bug
              while (!graphStack.empty()) {
                  int temp_index = graphStack.top();
                  isVisited.at(temp_index) = true;
                  graphStack.pop();
                  for (size_t i = 0; i < size; ++i) {
                      if (i == temp_index) { continue; }
                      if (isConnected.at(temp_index).at(i) == 1) {
                          isConnected.at(temp_index).at(i) = 2;
                          isConnected.at(i).at(temp_index) = 2;
                          graphStack.push(i);
                      }
                  }
              }
          } 
          return count; }
  ```
  

#### 721：[账户合并](https://leetcode-cn.com/problems/accounts-merge/description/)

- 解题思路：散列+并查集。不要考虑姓名，只考虑邮箱，每个邮箱对应于一个图的结点，对这个图进行并查集操作，就可以解出。这题想了一天。。。对容器的应用和并查集的应用要求十分高。下次试下用DFS写这题

  ```cpp
  int findRoot(vector<int> &parent, int index) {
      while (parent[index] != -1) { index = parent[index];}
      return index;
  }
  void unionVector(vector<int> &parent, vector<int> &rank, int i, int j) {
      int iRoot = findRoot(parent, i), jRoot = findRoot(parent, j);
      if(iRoot != -1 && iRoot == jRoot) { return; }
      else {
          if(rank[iRoot] < rank[jRoot]) { parent[iRoot] = jRoot; }
          else if(rank[iRoot] > rank[jRoot]) { parent[jRoot] = iRoot; }
          else { parent[iRoot] = jRoot; ++rank[jRoot]; }
      }
  }
  vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {
      // init
      unordered_map<string, int> email2Index;
      unordered_map<string, string> email2Name;
      int index = 0, size = accounts.size();
      vector<int> parentOfIndex, rankOfIndex;
      for (auto &emails : accounts) {
          string name = emails.at(0);
          int subSize = emails.size();
          for (int i = 1; i < subSize; i++) {
              email2Index[emails.at(i)] = index;
              email2Name[emails.at(i)] = name;
          }
          parentOfIndex.push_back(-1);
          rankOfIndex.push_back(0);
          ++index;
      }
      // union -> parent
      for (int emailIndex = 0; emailIndex < size; emailIndex++) {
          int subSize = accounts.at(emailIndex).size();
          for (int subIndex = 1; subIndex < subSize; subIndex++) {
              int currIndex = email2Index[accounts.at(emailIndex).at(subIndex)];
              if (currIndex != emailIndex) {	// 这里很关键
                  unionVector(parentOfIndex, rankOfIndex, currIndex, emailIndex);
              }
          }
      }
      // output
      vector<vector<string>> result;
      unordered_map<int, vector<string>> tempResult;
      for (auto &email : email2Index) {
          int root = findRoot(parentOfIndex, email.second);
          tempResult[root].push_back(email.first);
      }
      for (auto &items : tempResult){
          vector<string> temp{email2Name[items.second.at(0)]};
          sort(items.second.begin(), items.second.end());
          temp.insert(temp.end(), items.second.begin(), items.second.end());
          result.push_back(temp);
          }
      return result;
  }
  ```

  