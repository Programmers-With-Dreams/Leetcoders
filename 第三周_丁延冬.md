# 第三周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   3    |   7    | 42.86% |

## II 本周刷题总结

### 第1题 [二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

难度：中等

类型：树

方法：先序遍历+回溯法

#### a. 原题陈述

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

#### b. 解题思路

pathSum(root, sum) 主函数，返回res

recur(root, tar) 递归函数

​		递归基：root == null

​		目标值更新，路径记录（tar = tar - root.val，动态更新）

​		先序遍历左右节点

​		回溯前，需要将当前节点从path中删除。

注意：res.add(new Linkedlist(path))，因为添加的是一个对象，如果直接添加path会引起对象改变导致res改变的后果。

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    // res是可行的路径集合，path为每条可行的路径
    List<List<Integer>> res = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();   
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        recur(root,sum);
        return res;
    }
    public void recur(TreeNode root, int tar){
        if(root==null) return;
        path.add(root.val);
        tar = tar - root.val;
        if(tar==0 && root.left==null && root.right == null){
            res.add(new LinkedList(path));
        }
        // 左右先序遍历
        recur(root.left,tar);
        recur(root.right,tar);
        // 回溯
        path.removeLast();
    }
}
```

#### d. 其他解法摘录

以上方法的不优雅版

```java
public List<List<Integer>> pathSum(TreeNode root, int sum) {
    List<List<Integer>> result = new ArrayList<>();
    dfs(root, sum, new ArrayList<>(), result);
    return result;
}

public void dfs(TreeNode root, int sum, List<Integer> list,
                List<List<Integer>> result) {
    //如果节点为空直接返回
    if (root == null)
        return;
    //把当前节点值加入到list中
    list.add(new Integer(root.val));
    //如果到达叶子节点，就不能往下走了，直接return
    if (root.left == null && root.right == null) {
        //如果到达叶子节点，并且sum等于叶子节点的值，说明我们找到了一组，
        //要把它放到result中
        if (sum == root.val)
            result.add(new ArrayList(list));
        //注意别忘了把最后加入的结点值给移除掉，因为下一步直接return了，
        //不会再走最后一行的remove了，所以这里在rerurn之前提前把最后
        //一个结点的值给remove掉。
        list.remove(list.size() - 1);
        //到叶子节点之后直接返回，因为在往下就走不动了
        return;
    }
    //如果没到达叶子节点，就继续从他的左右两个子节点往下找，注意到
    //下一步的时候，sum值要减去当前节点的值
    dfs(root.left, sum - root.val, list, result);
    dfs(root.right, sum - root.val, list, result);
    //我们要理解递归的本质，当递归往下传递的时候他最后还是会往回走，
    //我们把这个值使用完之后还要把它给移除，这就是回溯
    list.remove(list.size() - 1);
}

```



------



### 第2题 [复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

难度：中等

类型：链表

方法：哈希/拼接拆分

#### a. 原题陈述

请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。

#### b. 解题思路

方法一：哈希法，Node与Node对应形成哈希，先构建表格再确定next和random

方法二：利用后序的对应关系，采用拼接、构建与拆分的方法

#### c. 解题代码

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        // 特殊情况
        if(head == null) return null;
        // 初始化Map--dic,以及节点--cur
        HashMap<Node,Node> dic = new HashMap<Node,Node>();
        Node cur = head;
        while(cur!=null){
            dic.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        // 匹配next和random关系
        // dic.foreach((key,value)->{
        //     value.next = dic.get(key.next);
        //     value.random = dic.get(key.random);
        // });
        for(Node a:dic.keySet()){
            dic.get(a).next = dic.get(a.next);
            dic.get(a).random = dic.get(a.random);
        }
        return dic.get(head);
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public Node copyRandomList(Node head) {
        // 方法2
        if(head == null) return null;
        // 1. 构建拼接链表
        Node cur = head;
        while(cur != null){
            Node tem = new Node(cur.val);
            tem.next = cur.next;
            cur.next = tem;
            // 向后迭代
            cur = tem.next;
        }
        cur = head;
        // 2. 构建random指向
        while(cur!=null){
            if(cur.random != null)
                cur.next.random = cur.random.next;
            cur = cur.next.next;
        }
        // 3. 拆分
        cur = head;
        Node pos = head.next;
        Node res = pos;
        // 注意此处微操
        while(pos.next!=null){
            cur.next = cur.next.next;
            pos.next = pos.next.next;
            cur = cur.next;
            pos = pos.next;
        }
        cur.next = null;
        pos.next = null;
        return res;
    }
}
```



------



### 第3题 [二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

难度：中等

类型：树

方法：中序遍历+双指针

#### a. 原题陈述

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

#### b. 解题思路

中序遍历，用双指针操作节点之间的关系

#### c. 解题代码

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre, head;
    public Node treeToDoublyList(Node root) {
        // 特殊情况
        if(root==null) return null;
        recur(root);
        head.left = pre;
        pre.right = head;
        return head;

    }
    // 平平无奇的中序遍历
    public void recur(Node cur){
        if(cur==null) return;
        recur(cur.left);
        if(pre!=null) pre.right = cur;
        else head = cur;
        cur.left = pre;
        pre = cur;
        recur(cur.right);
    }
}
```

#### d. 其他解法摘录

```

```



------



### 第4题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录

```

```



------



### 第5题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录

```

```



---



### 第6题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录

```

```



------



### 第7题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录

```

```

