# 第七周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   0    |   15   |   0%   |

## II 本周刷题总结

# 贪心算法

### 第1题 [分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

难度：简单

方法：贪心算法

#### a. 原题陈述

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

#### b. 解题思路

贪心，局部最优

#### c. 解题代码

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);// 排序
        Arrays.sort(s);
        int i = g.length - 1, j = s.length - 1, satisfacted_count = 0;
        while(i>=0 && j >=0){// 从右到左，依次满足
            if(g[i]<=s[j]){
                satisfacted_count++;
                j--;
                i--;
            }else{
                i--;
            }
        }
        return satisfacted_count;
    }
}
```

#### d. 其他解法摘录

简洁的代码

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);// 排序
        Arrays.sort(s);
        int child = 0, cookie = 0;
        while(child < g.length && cookie < s.length){
            if(g[child] <= s[cookie]) ++child;
            ++cookie;
        }
        return child;
    }
}
```

---

### 第2题 [分发糖果](https://leetcode-cn.com/problems/candy/)

难度：困难

方法：贪心算法

#### a. 原题陈述

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

#### b. 解题思路

只需要比较相邻的元素，两轮相反方向遍历进行操作即可

#### c. 解题代码

```java
class Solution {
    public int candy(int[] ratings) {
        // 初始化
        int len = ratings.length;
        int[] _res = new int[len];
        int i = 1;
        _res[0] = 1;
        // 双指针运算
        while(i < len){
            if(ratings[i-1] > ratings[i]){
                _res[i] = 1;
                int tmp = i;
                while(tmp > 0 && _res[tmp-1]==_res[tmp] && ratings[tmp-1]!= ratings[tmp]){// 回退更新相等的值
                    _res[tmp-1] = _res[tmp-1]+1;
                    tmp--;
                }
            }else if(ratings[i-1] < ratings[i]){
                _res[i] = _res[i-1]+1;
            }else{
                _res[i] = 1;
            }
            i++;
        }
        int sum = 0;
        for(int k : _res){
            sum += k;
        }
        return sum;
    }

}
```

#### d. 其他解法摘录

接近双百解法

贪心策略为，每次只考虑相邻的两个元素之间的关系

```java
class Solution {
    public int candy(int[] ratings) {
        // 初始化
        int ratings_len = ratings.length;
        int[] _res = new int[ratings_len];
        Arrays.fill(_res,1);
        for(int i = 1; i < ratings_len; i++ ){// 从左到右
            if(ratings[i-1] < ratings[i])
                _res[i] = _res[i-1]+1;
        }
        for(int i = ratings_len -1;i > 0; i--){// 从右到左
            if(ratings[i] < ratings[i-1]){
                _res[i-1] = Math.max(_res[i-1], _res[i]+1);
            }
        }
        int sum = 0;
        for(int i: _res){
            sum += i;
        }
        return sum;
    }
}
```

---

### 第3题 [无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

难度：中等

方法：贪心算法

#### a. 原题陈述

给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

注意:

可以认为区间的终点总是大于它的起点。
区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

#### b. 解题思路

排序，贪心

#### c. 解题代码

遇到的问题：Arrays.sort中Comparator的写法；数组变量未有效更新

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        // Arrays.sort(intervals,Comparator.comparingInt(a->a[0]));
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);
        int deleted_count = 0;
        for(int i = 1; i < intervals.length; i++){
            if(compare(intervals[i-1],intervals[i],i,intervals)){// 如果两个有重叠部分
                deleted_count++;
            }
        }
        return deleted_count;
    }

    boolean compare(int[] a1, int[] a2, int i, int[][] intervals){// 比较两个是否有重叠，如果有，设置小的在后面，返回true
        if(a1[1]>a2[0]){// 重叠
            if(a1[1] < a2[1]){
                intervals[i] = a1;
            }
            return true;
        }
        return false;
    }
}
```

#### d. 其他解法摘录

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int len = intervals.length;
        if(len==0) return 0;
        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);// 排序
        int deleted_count = 0, prev = intervals[0][1];// 初始化
        for(int i = 1; i < len; i++){
            if(intervals[i][0] < prev){// 如果两个有重叠部分
                deleted_count++;
                prev = Math.min(prev,intervals[i][1]);
            }else{
                prev = intervals[i][1];
            }
        }
        return deleted_count;
    }
}
```

---

### 第4题 [用最少数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

难度：中等

方法：贪心算法

#### a. 原题陈述

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。

#### b. 解题思路

贪心算法，先排序再比较，注意更新prev值

#### c. 解题代码

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length < 1) return 0;
        Arrays.sort(points,Comparator.comparingInt(a->a[0]));// 排序
        int count = 1, prev = points[0][1];// 初始化
        for(int i = 1; i < points.length; ++i){
            if(points[i][0] > prev){
                prev = points[i][1];
                count++;
            }else{
                prev = Math.min(prev,points[i][1]);// 更新prev
            }
        }
        return count;
    }
}
```

#### d. 其他解法摘录

Comparator返回值实现排序，返回负数则正排，正数则反排；注意越界的情况

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        if(points.length < 1) return 0;
//        Arrays.sort(points, Comparator.comparingInt(a->a[0]));// 排序
        Arrays.sort(points, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0]<o2[0]?-1:1;
            }
        });
        int count = 1, prev = points[0][1];// 初始化
        for(int i = 1; i < points.length; ++i){
            if(points[i][0] > prev){
                prev = points[i][1];
                count++;
            }else{
                prev = Math.min(prev,points[i][1]);
            }
        }
        return count;
    }
}
```

---

### 第5题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第6题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第7题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第8题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第9题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第10题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第11题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第12题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第13题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第14题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

### 第15题 

难度：

方法：

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```java

```

#### d. 其他解法摘录

```java

```

---

