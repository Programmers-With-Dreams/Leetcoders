# 第一周_丁延冬

## I 本周目标

| 完成量 | 目标值 | 完成度 |
| :----: | :----: | :----: |
|   1    |   3    | 33.33% |

## II 本周刷题总结

### 第1题 [树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/comments/)

难度：中等

类型：树

方法：树的遍历

#### a. 原题陈述

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)。B是A的子结构， 即 A中有出现和B相同的结构和节点值。

#### b. 解题思路

将问题分解成（1）定位B根节点在A中的位置集合ArrayList<TreeNode> B_pos, 使用search函数实现；

​						（2）比较两个相同值的节点作为根节点的树结构是否一致，使用compare函数实现。

#### c. 解题代码

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        // B是空，则返回false
        if(B==null) return false;
        // 定位B根节点在A中的位置,可能会有很多个
        ArrayList<TreeNode> B_pos = new ArrayList<TreeNode>();
        B_pos = search(A,B,B_pos);
        
        // 比较选择出来的B根节点在A中的位置与B根节点作为根节点的树形状是否一样
        for(int i = 0; i < B_pos.size(); i++){
            boolean flag = compare(B_pos.get(i),B);
            if(flag == true){
                return true;
            }
        }
        return false;
    }

    public ArrayList<TreeNode> search(TreeNode A, TreeNode B,ArrayList<TreeNode> B_pos){
        if(A==null) return B_pos;
        if(A.val == B.val) B_pos.add(A);
        // 分别从A的左右子树中寻找等于B值的节点
        search(A.left,B,B_pos);
        search(A.right,B,B_pos);
        return B_pos;
    }

    public boolean compare(TreeNode A, TreeNode B){
        if(B==null) return true;
        if(A==null) return false;
        boolean flag_l;
        boolean flag_r;
        if(A.val == B.val){
            // flag_l, flag_r 分别表示左右子树的返回值
            flag_l = compare(A.left,B.left);
            flag_r = compare(A.right,B.right);
        }else{
            // 要是当前节点值不等，flag为false，不存在flag_l和flag_r了
            return false;
        }
        // 每个节点的返回值由左右节点的boolean值构成
        return flag_l&flag_r;
    }
}
```

#### d. 其他解法摘录

```java
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A == null || B == null) return false;
        // 这个||用得很有灵魂，只要有一个满足就行，值得学习！
        return dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);
    }
    public boolean dfs(TreeNode A, TreeNode B){
        if(B == null) return true;
        if(A == null) return false;
        // 注：返回A与B的值是否相等，以及A，B的左右节点是否相等。作为一个整体返回当前节点的总体boolean值
        return A.val == B.val && dfs(A.left, B.left) && dfs(A.right, B.right);
    }
```

简洁的代码，机智的灵魂，值得学习。

------



### 第2题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录



------



### 第3题

#### a. 原题陈述



#### b. 解题思路



#### c. 解题代码

```

```

#### d. 其他解法摘录


