# 第七周_付清晨

本周主要是 `贪心算法`、`记忆化搜索` 、`动态规划` 的中等题。

## I 本周目标


|    分类    |        计划完成题目        | 已完成数量 |
| :--------: | :------------------------: | :--------: |
|  贪心算法  |       322，1217，55        |     3      |
| 记忆化搜索 |          509，322          |     2      |
|  动态规划  | 509，62，121，70，279，221 |     6      |
|    汇总    |           共9题            |     9      |

## II 本周刷题总结

### 贪心算法

|  题目   | 难度 |                             描述                             |
| :-----: | :--: | :----------------------------------------------------------: |
| **322** | 中等 | 给定不同面额的硬币和总金额 ，计算可凑成总金额的最少的硬币数（每种硬币的数量是无限的）。如果没有返回 `-1`。 |
|  1217   | 简单 | 数轴上放置了一些筹码，每个筹码的位置存在数组 `chips` 当中。你可以对 **任何筹码** 执行 ①移动两个位置，代价为0 ②移动 1 个单位，代价为 1，计算返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 |
|   721   | 中等 | 给定一个跳跃的最大长度数组 `nums` ，你最初位于数组的 **第一个下标** ，判断你是否能够到达最后一个下标。 |

#### 322：[零钱兑换](https://leetcode-cn.com/problems/coin-change/description/)

- 贪心 + 剪枝（会超时）
  - 先给数组排个序，按照从大到小的顺序，这样可以先处理大的硬币
  - 然后就可以分解为子问题 f(amount) = f(amount - coin[i]*num) + num 。这里可以用乘法加速。
  - 当amount == 0时，说明查找成功，记录下当前的硬币数量 coinNums。（可以通过条件设置amount不会<0）查找失败则返回上一个子问题
  - 这个里面可以进行剪枝来加速，例如当前硬币数超过了记录的最小硬币数就不需要再往前进行下去了。

  ```cpp
      void coinRec(vector<int> &coins, int leftAmount, int &minCount, int currCount, int index) {
          if (leftAmount == 0) { 
              if (minCount == -1) { minCount = currCount; }
              else if (currCount < minCount) { minCount = currCount; }
              return;	// 查找成功
          }
          if ((minCount != -1 && minCount <= currCount) || index == coins.size()) { return; }	// 剪枝
          for (int itemCount = (leftAmount/coins[index]); itemCount >= 0; --itemCount) {
              coinRec(coins, leftAmount - itemCount*coins[index], minCount, currCount + itemCount, index + 1);
          }
      }
  int coinChange(vector<int>& coins, int amount) {
          if (amount == 0) { return 0; }
          sort(coins.rbegin(), coins.rend());
          int minCount = -1;
          coinRec(coins, amount, minCount, 0, 0);
          return minCount;
      }
  ```

  - 动态规划
    - 如果硬币的面额数组为 coin[i]，有状态方程 $f(\text{amount}) = \min\{ f(\text{amount} - \text{coin}[i]) \} + 1$，$f(0) = 0$
    - 对 f(amount) 中的每个 amount ，遍历每个 coin[i] 计算 f(amount - coin[i]) ，找到最小值。如果 amount - coin[i] 就不管

  ```cpp
      int coinChange(vector<int>& coins, int amount) {
          if (amount == 0) { return 0; }
          sort(coins.begin(), coins.end());
          vector<int> dp(amount + 1, amount + 1);
          dp[0] = 0;
          int size = coins.size();
          for (int a = 1; a <= amount; ++a) {
              for (int i = 0; i < size; ++i) {
                  if (a < coins.at(i)) { break; }
                  else {dp[a] = min(dp[a], dp[a - coins.at(i)]);}
              }
              ++dp[a];
          }
          return dp.at(amount) > amount ? -1 : dp.at(amount);
      }
  ```

#### 1217：[玩筹码](https://leetcode-cn.com/problems/minimum-cost-to-move-chips-to-the-same-position/description/)

跟贪心算法好像没啥关系

- 转换成求奇数数量和偶数数量的最小值

  ```cpp
      int minCostToMoveChips(vector<int>& position) {
          int count = 0, size = position.size();
          for (auto &item : position) { count += item & 1; }
          return count < size - count ? count : size - count;
      }
  ```
  

#### 55：[跳跃游戏](https://leetcode-cn.com/problems/jump-game/description/)

这个搞不了啥花样，还是老老实实遍历一遍效果好

- 遍历数组，记录下当前能跳到的最远距离，如果最远坐标超过了当前的坐标，就无法到达

  ```cpp
      bool canJump(vector<int>& nums) {
          int max = 0, size = nums.size();
          for (int i = 0; i < size; ++i) {
              if (i > max) { return false; }
              max = max < i + nums.at(i) ? i + nums.at(i) : max;
          }
          return true;
      }
  ```

### 记忆化搜索

| 题目 | 难度 |            描述            |
| :--: | :--: | :------------------------: |
| 509  | 简单 | 计算 **斐波那契数** `F(n)` |

经典例题

```cpp
    int fib(int n) {
        int frontFib = 0, Fib = 1, temp;
        if (!n) { return 0; }
        while (--n){ temp = frontFib; frontFib = Fib; Fib = temp + frontFib; }
        return Fib;
    }
```

### 动态规划

| 题目 | 难度 |                             描述                             |
| :--: | :--: | :----------------------------------------------------------: |
|  62  | 中等 | 一个机器人位于一个 `m x n` 网格的左上角，每次只能向下或者向右移动一步，它试图达到网格的右下角。问总共有多少条不同的路径？ |
| 121  | 简单 | 给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。 |
|  70  | 简单 | 假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。求可以爬到楼顶的方式数量。 |
| 279  | 中等 | 给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。 |
| 221  |      |                                                              |

#### 62：[不同路径](https://leetcode-cn.com/problems/unique-paths/description/)

- $f(i,j) = f(i,j - 1) + f(i - 1, j)$，$f(i,0) = f(0,j)$ = 1

  ```cpp
      int uniquePaths(int m, int n) {
          vector<int> dp(n, 1);
          for (int i = 0; i < m - 1; ++i) {
              for (int i = 1; i < n; ++i) {
                  dp[i] += dp[i - 1];
              }
          }
          return dp[n - 1];
      }
  ```

#### 121：[买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/)

- 这也是经典题目，维护一个数，记录最高点

  ```cpp
      int maxProfit(vector<int>& prices) {
          int size = prices.size(), max = 0, profit = 0;
          for (int i = size - 1; i >= 0; --i) {
              max = max < prices.at(i) ? prices.at(i) : max;
              profit = profit < max - prices.at(i) ? max - prices.at(i) : profit;
          }
          return profit;
      }
  ```

#### 70：[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/description/)

- 经典题目

  ```cpp
      int climbStairs(int n) {
          // f(i) = f(i - 1) + f(i - 2), f(1) = 1,f(2) = 2
          if (n == 1) { return 1; }
          if (n == 2) { return 2; }
          int low = 1, curr = 2;
          for (int i = 3; i <= n; ++i) {
              int temp = curr;
              curr += low;
              low = temp;
          }
          return curr;
      }
  ```

#### 279：[完全平方数](https://leetcode-cn.com/problems/perfect-squares/description/)

- 和 322：硬币兑换时一个套路

  ```cpp
      int numSquares(int n) {
          // f(n) = min{f(n - num[i]*num[i])} + 1
          vector<int> squares;
          for (int i = sqrt(n); i > 0; --i) { squares.push_back(i); }
          vector<int> dp(n + 1, 10001);
          dp[0] = 0;
          for (int i = 1; i < n + 1; ++i) {
              int minCost = 10001;
              for (auto &square : squares) {
                  int cal = i - square * square;
                  if (cal < 0) { continue; }
                  else { if (dp[cal] < minCost) { minCost = dp[cal]; } }
              }
              dp[i] = minCost + 1;
          }
          return dp[n];
      }
  ```

#### 221：[最大正方形](https://leetcode-cn.com/problems/maximal-square/description/)

- 动态规划：这个题目动态规划的表达式比较难找，其实就是三者取最小![](https://pic.leetcode-cn.com/8c4bf78cf6396c40291e40c25d34ef56bd524313c2aa863f3a20c1f004f32ab0-image.png)

  ```cpp
      int maximalSquare(vector<vector<char>>& matrix) {
          // square[i,j] = min{square[i - 1,j], square[i - 1,j - 1], square[i,j - 1]} + 1
          int sizeR = matrix.size(), sizeC = matrix.at(0).size(), maxSquare = 0;
          vector<int> temp(sizeC + 1, 0);
          vector<vector<int>> square(sizeR + 1, temp);
          for (int i = 0; i < sizeR; ++i) {
              for (int j = 0; j < sizeC; ++j) {
                  if (matrix[i - 1][j - 1] == '0') { square[i][j] = 0; continue; }
                  int min = square[i - 1][j - 1];
                  if (square[i - 1][j] < min) { min = square[i - 1][j]; }
                  if (square[i][j - 1] < min) { min = square[i][j - 1]; }
                  square[i][j] = ++min;
                  if(maxSquare < min) { maxSquare = min; }
              }
          }
          return maxSquare*maxSquare;
      }	// 还可以优化以节省空间
  ```

- 二进制解法 ：https://leetcode-cn.com/problems/maximal-square/solution/fen-xiang-yi-ge-bu-yong-dong-tai-gui-hua-cai-yong-/
  - 把矩阵每一行看作二进制数的表示形式，进而转成数字，得到一个一维数组；
  - 用 2 个指针 i,j 分别表示开始行和最后一行，这2行之间的所有行（包括这 2 行）全部相与，看能得到多少个连续最多的 1，亦即求宽度，而高度则等于 j-i+1。枚举所有的(i,j) 组合，并保存结果中的最大值。
  - 如何求一个数中连续最多的 1？小技巧：每次将这个数和它左移一位后的数相与，直到它变成 0，记录操作次数，这个操作次数就是连续最多的 1。举个例子：
    - 对于数字 10101010，将这个数和它左移一位后的数相与，操作1次，这个数就变成 0 了，连续最多的 1只有 1 个
    - 对于数字 10101110，操作 1 次得到 00001100，还需再操作2次才能得到 0，所以连续最多的 1是 3
      相当于每次都错一位相与，所以这个数最多有几个连续的 1，就能错一位相与几次才能得到 0。

```python
class Solution:
    def getWidth(self,num):  #步骤3：求一个数中连续最多的1
        w=0
        while num>0:
            num&=num<<1
            w+=1
        return w
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        nums=[int(''.join(n),base=2) for n in matrix]  #步骤1：每一行当作二进制数
        res,n=0,len(nums)
        for i in range(n):   #步骤2：枚举所有的组合，temp存储相与的结果
            temp=nums[i]
            for j in range(i,n):
                temp&=nums[j]
                if self.getWidth(temp)<j-i+1:
                    break
                res=max(res,j-i+1)
        return res*res
```

