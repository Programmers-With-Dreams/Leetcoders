# 第三周_付清晨

本周主要是 `Set`、`Heap` 的简单题和 `双指针算法` 、`二分查找法` 的中等题。熟悉下各个数据结构的操作。

## I 本周目标

|    分类    |   计划完成题目   | 已完成数量 |
| :--------: | :--------------: | :--------: |
|    Set     |       705        |     1      |
|    Heap    |     215，692     |     2      |
| 双指针算法 |  141，344，881   |     3      |
| 二分查找法 | 704，35，162，74 |     4      |
|    汇总    |      共10个      |     9      |

## II 本周刷题总结

### Set：[设计哈希集合](https://leetcode-cn.com/problems/design-hashset/description/)

#### a. 原题描述

就是字面意思，不用STL的关联容器

#### b. 解题思路

有多种方法

- 题目bug：`key` 最多10^6 个，建一个10^6 的数组，里面填出现了没
- 单链表法
- 开放寻址法

#### c. 解题代码

这个解法是双向平方探测的开放寻址法

```cpp
class MyHashSet {
public:
    MyHashSet() { for (auto &item : datas) { item = -1; } }
    void add(int key) { datas.at(search(key)) = key; }
    void remove(int key) { datas.at(search(key)) = -2; } //由于remove，可能导致中间会出现空槽
    bool contains(int key) {
        if (datas.at(search(key)) < 0) { return false; }
        else { return true; }
    }
private:
    array<int, 10007> datas;
    int length = 10007;
    int hash(int key) { return ((key * 2 + 1 + length) % length); }
    int search(int key) {
        int hash_value = hash(key), flag = 1, mul = 1, index = hash_value;
        while (datas.at(index) != -1) {
            if(datas.at(index) == key) { return index; }
            index = (hash_value + flag * mul + length) % length;
            if (flag == -1) { ++mul; } flag *= -1;
        }
        return index;
    }   // 查找失败返回下一个空位置的 index
};
```

#### d.其他解法

题目bug法

```cpp
class MyHashSet {
public:
    int arraylist[1000001];    
    MyHashSet() { fill(arraylist,arraylist+1000001,0); }
    void add(int key) { arraylist[key]=1; }
    void remove(int key) { arraylist[key]=0; }
    bool contains(int key) {
        if (arraylist[key]==1){ return true; }
        else return false;       
    }
};
```

单链表法

```cpp
class MyHashSet {
private:
    struct Node{ int val; Node*next; Node(int val):val(val),next(NULL){}; };
    const int len=1000;
    vector<Node*>bucket;
public:
    MyHashSet() { bucket=vector<Node*>(len,new Node(-1)); }
    void add(int key) {
        Node*dummy=bucket[key%len];
        while(dummy->next!=NULL){ if(dummy->next->val==key) return; dummy=dummy->next; }
        dummy->next=new Node(key);
    }
    void remove(int key) {
        Node*dummy=bucket[key%len];
        while(dummy->next!=NULL){
            if(dummy->next->val==key){ dummy->next=dummy->next->next; break; }
            dummy=dummy->next;
        }
    }
    bool contains(int key) {
        Node*dummy=bucket[key%len];
        while(dummy->next!=NULL){ 
            if(dummy->next->val==key) return true;
            dummy=dummy->next;
        }
        return false;
    }
};
```

### Heap：[数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/)、[前K个高频单词](https://leetcode-cn.com/problems/top-k-frequent-words/description/)

#### a. 原题描述

就是字面意思，找到数组的第K大元素和前K个高频单词

#### b. 解题思路

- 数组中的第K个最大元素：先将数据排序，然后返回 `nums[k]`
- 前K个高频单词：首先将数据储存在 `map` 中，`key` 对应单词，`value` 对应出现次数。然后把他们放在优先队列中排序。再通过 `top(),pop()` 操作输出到 `vector` 中

#### c. 解题代码

 [215.数组中的第k个最大元素.cpp](Source\215.数组中的第k个最大元素.cpp) 

```cpp
    int findKthLargest(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        return(nums.at(nums.size() - k));
    } //额。。偷懒了
```

 [692.前k个高频单词.cpp](Source\692.前k个高频单词.cpp) 

```cpp
    vector<string> topKFrequent(vector<string>& words, int k) {
        // 题目要求 计数从大到小排->字母从小到大排
        unordered_map<string, int> datas_map;
        for (auto &word : words) { ++datas_map[word]; }
        
        priority_queue<pair<int, string>> datas_heap;
        for (auto &data : datas_map) { 
            datas_heap.push({-data.second, data.first});
            if (k < datas_heap.size()) { datas_heap.pop(); }
        }   // 此时计数从小到大排->字母从大到小排
        
        vector<string> topKdatas;
        for (int i = 0; i < k; ++i) {
            topKdatas.push_back(datas_heap.top().second);
            datas_heap.pop();
        }
        reverse(topKdatas.begin(), topKdatas.end());    // 反过来
        return topKdatas;
    }
```

#### d.其他解法

215：这题再排序上还有蛮多操作，可以用快速排序，堆排序等等。这个专题时堆排序，就实现了这个。

- 用STL实现

```cpp
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> data;
        for (auto &item : nums){ data.push(item); }
        for (int i = 0; i < k - 1; ++i) { data.pop(); }
        return data.top();
    }	// 也算是偷懒了
```

- 手动实现

```cpp
class Solution {
public:
    void heapity(vector<int>& nums, int index, int size) {	
        // size是为了findKthLargest()
        int lc = 2 * index + 1, rc = 2 * index + 2, value = nums.at(index);
        do{	// 这里也可以用递归实现，用迭代的话就需要注意各种边界条件
            if (size <= lc){ return; }
            else if (size == rc && value < nums.at(lc)) { 
                nums.at(index) = nums.at(lc); nums.at(lc) = value; return;
            }
            else if (rc < size && (value < nums.at(lc) || value < nums.at(rc))) {
                int max = nums.at(lc) < nums.at(rc) ? rc : lc;
                nums.at(index) = nums.at(max); nums.at(max) = value;
                index = max; lc = 2 * index + 1; rc = 2 * index + 2;
            }
            else { return; }
        } while (true);
    }
    void buildHeap(vector<int>& nums) {
        int size = nums.size();
        for (int i = (size >> 1) - 1; i >= 0; --i) { heapity(nums, i, size); }
    }
    int findKthLargest(vector<int>& nums, int k) {
        buildHeap(nums);
        int size = nums.size();
        for (int i = size - 1; i >= size - k + 1; --i){
            nums.at(0) = nums.at(i);
            heapity(nums, 0, i);
        }
        return nums.at(0);
    }
};
```

### 双指针算法：[环形链表](https://leetcode-cn.com/problems/linked-list-cycle/description/)、[反转字符串](https://leetcode-cn.com/problems/reverse-string/description/)、[救生艇](https://leetcode-cn.com/problems/boats-to-save-people/description/)

#### a. 原题描述

- 环形链表：判断链表中是否有环

- 反转字符串：字面意思，但是不能额外给另外的数组分配空间
- 救生艇：一个船中两个人，限额 `limit`，给定一组人的总量，求最少人数

#### b. 解题思路

- 环形链表
  - 最简单的方法就是不断插入 `ListNode.next` 到散列表中，插入失败会返回 `bool`类型的变量，根据返回值就可以得出结果
  - 然后可以根据题目 `bug ` ,数组最长 `10000`，遍历`10001`次后还不结束的就是有环的
  - **设置快慢指针**：快指针一次走两步，慢指针一次走一步，两个相遇就说明有环。这种方法要注意边界条件。 还有初始时快慢指针不能一样（要不然就直接跳出循环）

- 反转字符串和救生艇：最常规的双指针法。

#### c. 解题代码

 [141.环形链表.cpp](Source/141.环形链表.cpp) 

```cpp
    bool hasCycle(ListNode *head) {
        unordered_set<ListNode *> data;
        while (head != nullptr){
            if (!data.insert(head).second){ return true; }
            head = head->next;          
        }
        return false;
    }
```

 [344.反转字符串.cpp](Source/344.反转字符串.cpp) 

```cpp
    void reverseString(vector<char>& s) {
        int head = 0, tail = s.size() - 1;
        while (head < tail){
            int temp = s.at(head); s.at(head) = s.at(tail); s.at(tail) = temp;
            ++head; --tail;
        }
    }
```

 [881.救生艇.cpp](Source/881.救生艇.cpp) 

```cpp
    int numRescueBoats(vector<int>& people, int limit) {
        sort(people.begin(), people.end());
        int begin = 0, end = people.size() - 1, count = 0;
        while (begin <= end){
            if (people.at(end) + people.at(begin) <= limit){ ++begin; } 
            --end; ++count; }
        return count;
    }
```

#### d. 其他解题方法

环形链表：利用题目bug

```cpp
    bool hasCycle(ListNode *head) {
        int n = 0;
        while (head){
            if(n > 10001){ return true; }
            head = head->next;
            ++n; }
        return false;
    }
```

**环形链表：快慢指针**

```cpp
    bool hasCycle(ListNode *head) {
        if(!(head && head->next)){ return false; }
        ListNode *slow = head, *fast = head->next;
        while (slow != fast){
            if (!(fast && fast->next)){ return false; }
            slow = slow->next;
            fast = fast->next->next;
        }
        return true;
    }
```

### 二分查找法：[二分查找](https://leetcode-cn.com/problems/binary-search/description/)、[搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/description/)、[寻找峰值](https://leetcode-cn.com/problems/find-peak-element/description/)、[搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/description/)

#### a. 原题陈述

- 二分查找、搜索插入位置、搜索二维矩阵：都是非常传统的二分搜索题目
- **寻找峰值**：一般二分查找都需要序列有序，但是这题是在无序的序列中查找。这题通过二分查找搜索来限制位置，非常的巧妙。

#### b. 解题思路

- **寻找峰值**

  - 遍历数组找到 `a<b>c` 注意的数

  - **二分查找法**：就峰值三种情况一个在数组首，一个在数组中间，一个在数组末尾。

    前两个分情况讨论就可以了。

    对于第三种：只要出现 `nums[i] < nums[i + 1]` ，就说明有峰值在 `i` 右边。按照这个思路可以实现 $O(\lg N)$ 的复杂度

#### c.解题代码

[704.二分查找.cpp](Source/704.二分查找.cpp) 

```cpp
    int search(vector<int>& nums, int target) {
        size_t size = nums.size();
        unsigned int begin = 0, end = size, mid = (begin + end) >> 1;
        while ((begin + 1) != end){
            if (nums.at(mid) <= target){ begin = mid; }
            else { end = mid; }
            mid = (begin + end) >> 1;
        }
        if (target != nums.at(begin)){ return -1; }
        return begin;
    }
```

 [35.搜索插入位置.cpp](Source/35.搜索插入位置.cpp) 基本上和704相同

 [162.寻找峰值.cpp](Source/162.寻找峰值.cpp) 

```cpp
    int findPeakElement(vector<int>& nums) {
        int begin = 0, end = nums.size() - 1;
        if (end == 1 || nums.at(1) < nums.at(0)){ return 0; }
        if (nums.at(end - 2) < nums.at(end - 1)){ return end - 1; }
        ++begin; --end;
        for (int i = 1; i < size; i++){
            if (nums.at(i - 1) < nums.at(i)){
                if (nums.at(i + 1) < nums.at(i)){ return i; } } }
        return -1;
    }
```

 [74.搜索二维矩阵.cpp](Source/74.搜索二维矩阵.cpp) 

```cpp
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int size_row = matrix.size(), size_column = matrix.at(0).size();
        int begin = 0, end = size_row * size_column, mid = (begin + end) >> 1;
        // (mid / size_column, mid % size_column)
        while (begin + 1 != end){
            if (matrix.at(mid / size_column).at(mid % size_column) <= target){ begin = mid; }
            else { end = mid; }
            mid = (begin + end) >> 1;
        }
        if (matrix.at(begin / size_column).at(begin % size_column) == target){ return true; }
        return false;
    }
```

#### d. 其他解题

**162.寻找峰值: 二分版本**

```cpp
    int findPeakElement(vector<int>& nums) {
        int begin = 0, end = nums.size() - 1;
        while (begin < end){
            int mid = (begin + end) >> 1;
            if (nums.at(mid) < nums.at(mid + 1)){ begin = mid + 1; }
            else { end = mid; }
        }
        return begin;
    }
```

